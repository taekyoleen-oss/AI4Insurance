---
title: "와이블분포를 활용한 보험 생존시간 모델링"
date: "2025-02-03"
category: "distributions"
tags: ["와이블분포", "생존시간", "모델링"]
excerpt: "와이블분포의 이론적 배경과 보험 생존시간 모델링에서의 활용법을 살펴보고, 위험률 함수와 실무 적용 사례를 제공합니다."
---

와이블분포(Weibull Distribution)는 보험업계에서 생존시간 모델링에 매우 유용한 분포입니다. 특히 시간에 따른 위험률 변화를 모델링할 수 있어, 보험 사고의 발생 패턴을 더 정확하게 분석할 수 있습니다.

## 와이블분포의 정의와 특성

와이블분포는 두 개의 매개변수 α(형상모수)와 β(척도모수)를 가지는 연속확률분포입니다:

```
f(x) = (α/β) * (x/β)^(α-1) * e^(-(x/β)^α), x ≥ 0
```

여기서:
- **α (alpha)**: 형상모수 (shape parameter)
- **β (beta)**: 척도모수 (scale parameter)

### 와이블분포의 주요 특성

1. **지지집합**: x ≥ 0 (양의 값만)
2. **평균**: E[X] = β * Γ(1 + 1/α)
3. **분산**: Var[X] = β² * [Γ(1 + 2/α) - Γ²(1 + 1/α)]
4. **위험률 함수**: h(x) = (α/β) * (x/β)^(α-1)
5. **유연성**: α 값에 따라 다양한 위험률 패턴 가능
   - α < 1: 위험률 감소 (초기 위험 높음)
   - α = 1: 위험률 일정 (지수분포)
   - α > 1: 위험률 증가 (시간 경과에 따른 위험 증가)

## 보험업계에서의 와이블분포 활용

### 1. 생존시간 모델링의 장점

와이블분포가 보험 생존시간 모델링에 적합한 이유:

- **위험률 변화**: 시간에 따른 위험률 변화 모델링 가능
- **유연성**: 다양한 생존 패턴 모델링 가능
- **실용성**: 실제 보험 데이터와 잘 맞음

### 2. 파이썬을 활용한 와이블분포 모델링

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from scipy.optimize import minimize
import pandas as pd

# 와이블분포 매개변수 추정 함수
def estimate_weibull_params(data):
    """최대우도추정법을 통한 와이블분포 매개변수 추정"""
    
    def negative_log_likelihood(params):
        alpha, beta = params
        if alpha <= 0 or beta <= 0:
            return np.inf
        return -np.sum(stats.weibull_min.logpdf(data, alpha, scale=beta))
    
    # 초기값 설정 (방법 1: 모멘트 추정법)
    mean_data = np.mean(data)
    var_data = np.var(data, ddof=1)
    
    # 초기값 설정 (방법 2: 경험적 추정)
    alpha_init = 1.0
    beta_init = mean_data
    
    # 최적화
    result = minimize(negative_log_likelihood, 
                     [alpha_init, beta_init], 
                     method='L-BFGS-B',
                     bounds=[(0.01, None), (0.01, None)])
    
    return result.x[0], result.x[1]

# 실제 생존시간 데이터 (예시)
np.random.seed(42)
true_alpha, true_beta = 2.0, 100.0
survival_times = np.random.weibull(true_alpha, 1000) * true_beta

# 매개변수 추정
estimated_alpha, estimated_beta = estimate_weibull_params(survival_times)

print(f"실제 매개변수: α={true_alpha}, β={true_beta}")
print(f"추정 매개변수: α={estimated_alpha:.3f}, β={estimated_beta:.3f}")
```

### 3. 와이블분포 적합도 검정

```python
def weibull_goodness_of_fit(data, alpha, beta):
    """와이블분포 적합도 검정"""
    
    # Kolmogorov-Smirnov 테스트
    ks_stat, ks_pvalue = stats.kstest(data, 
                                      lambda x: stats.weibull_min.cdf(x, alpha, scale=beta))
    
    # Anderson-Darling 테스트
    ad_stat, ad_critical, ad_significance = stats.anderson(data, dist='weibull_min')
    
    print(f"Kolmogorov-Smirnov 통계량: {ks_stat:.4f}")
    print(f"KS p-value: {ks_pvalue:.4f}")
    print(f"Anderson-Darling 통계량: {ad_stat:.4f}")
    
    return ks_stat, ks_pvalue, ad_stat

# 적합도 검정 실행
ks_stat, ks_pvalue, ad_stat = weibull_goodness_of_fit(survival_times, estimated_alpha, estimated_beta)
```

### 4. 시각화 및 분석

```python
def visualize_weibull_fit(data, alpha, beta):
    """와이블분포 적합 결과 시각화"""
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    
    # 히스토그램과 적합된 분포
    ax1.hist(data, bins=50, density=True, alpha=0.7, color='skyblue', label='실제 데이터')
    x_range = np.linspace(0, np.max(data), 1000)
    fitted_pdf = stats.weibull_min.pdf(x_range, alpha, scale=beta)
    ax1.plot(x_range, fitted_pdf, 'r-', linewidth=2, label='와이블분포 적합')
    ax1.set_title('와이블분포 적합 결과')
    ax1.set_xlabel('생존시간')
    ax1.set_ylabel('확률밀도')
    ax1.legend()
    
    # Q-Q 플롯
    stats.probplot(data, dist=stats.weibull_min, sparams=(alpha, 0, beta), plot=ax2)
    ax2.set_title('Q-Q 플롯 (와이블분포)')
    
    # 위험률 함수
    hazard_rate = (alpha/beta) * (x_range/beta)**(alpha-1)
    ax3.plot(x_range, hazard_rate, 'g-', linewidth=2, label='위험률 함수')
    ax3.set_title('위험률 함수')
    ax3.set_xlabel('시간')
    ax3.set_ylabel('위험률')
    ax3.legend()
    
    # 생존함수
    survival_func = stats.weibull_min.sf(x_range, alpha, scale=beta)
    ax4.plot(x_range, survival_func, 'b-', linewidth=2, label='생존함수')
    ax4.set_title('생존함수')
    ax4.set_xlabel('시간')
    ax4.set_ylabel('생존확률')
    ax4.legend()
    
    plt.tight_layout()
    plt.show()

# 시각화 실행
visualize_weibull_fit(survival_times, estimated_alpha, estimated_beta)
```

## 위험률 함수 분석

### 1. 위험률 함수의 특성

```python
def analyze_hazard_rate(alpha, beta, time_range):
    """위험률 함수 분석"""
    
    x_range = np.linspace(0, time_range, 1000)
    hazard_rate = (alpha/beta) * (x_range/beta)**(alpha-1)
    
    # 위험률 패턴 분석
    if alpha < 1:
        pattern = "위험률 감소 (초기 위험 높음)"
    elif alpha == 1:
        pattern = "위험률 일정 (지수분포)"
    else:
        pattern = "위험률 증가 (시간 경과에 따른 위험 증가)"
    
    print(f"위험률 패턴: {pattern}")
    print(f"초기 위험률: {hazard_rate[1]:.4f}")
    print(f"최종 위험률: {hazard_rate[-1]:.4f}")
    
    return x_range, hazard_rate

# 위험률 분석
time_range = 200
x_range, hazard_rate = analyze_hazard_rate(estimated_alpha, estimated_beta, time_range)
```

### 2. 생존함수 분석

```python
def analyze_survival_function(alpha, beta, time_points):
    """생존함수 분석"""
    
    survival_probs = stats.weibull_min.sf(time_points, alpha, scale=beta)
    
    print("생존확률 분석:")
    for i, (time, prob) in enumerate(zip(time_points, survival_probs)):
        print(f"  {time}일 후 생존확률: {prob:.4f}")
    
    return survival_probs

# 생존함수 분석
time_points = [50, 100, 150, 200]
survival_probs = analyze_survival_function(estimated_alpha, estimated_beta, time_points)
```

## 엑셀을 활용한 와이블분포 분석

### 1. 기본 설정

```excel
A1: 형상모수 (α)
B1: 2.0
A2: 척도모수 (β)
B2: 100.0
A3: 시간
B3: 100
```

### 2. 와이블분포 함수 활용

```excel
# 와이블분포 확률밀도함수
A5: =WEIBULL.DIST(x, α, β, FALSE)

# 와이블분포 누적분포함수
A6: =WEIBULL.DIST(x, α, β, TRUE)

# 와이블분포 역함수
A7: =WEIBULL.INV(확률, α, β)
```

### 3. 위험률 함수 계산

```excel
A10: 위험률 함수
B10: =(B1/B2)*((B3/B2)^(B1-1))

A11: 생존함수
B11: =EXP(-((B3/B2)^B1))

A12: 평균 생존시간
B12: =B2*GAMMA(1+1/B1)
```

## 고급 분석 기법

### 1. 베이지안 추정

```python
import pymc3 as pm

def bayesian_weibull_estimation(data):
    """베이지안 방법을 통한 와이블분포 매개변수 추정"""
    
    with pm.Model() as model:
        # 사전분포 설정
        alpha = pm.Gamma('alpha', alpha=1, beta=1)
        beta = pm.Gamma('beta', alpha=1, beta=1)
        
        # 우도함수
        likelihood = pm.Weibull('likelihood', alpha=alpha, beta=beta, observed=data)
        
        # MCMC 샘플링
        trace = pm.sample(2000, tune=1000, cores=2)
    
    return trace

# 베이지안 추정 실행
trace = bayesian_weibull_estimation(survival_times)
pm.traceplot(trace)
plt.show()
```

### 2. 혼합와이블분포 모델

```python
def mixture_weibull_model(data, n_components=2):
    """혼합와이블분포 모델"""
    
    from sklearn.mixture import GaussianMixture
    
    # 로그 변환 (정규분포에 가깝게)
    log_data = np.log(data)
    
    # EM 알고리즘을 통한 혼합분포 추정
    gmm = GaussianMixture(n_components=n_components, random_state=42)
    gmm.fit(log_data.reshape(-1, 1))
    
    return gmm

# 혼합모델 적용
mixture_model = mixture_weibull_model(survival_times)
print(f"혼합분포 가중치: {mixture_model.weights_}")
print(f"혼합분포 평균: {mixture_model.means_.flatten()}")
print(f"혼합분포 분산: {mixture_model.covariances_.flatten()}")
```

## 실무 적용 사례

### 사례 1: 생명보험 생존시간 모델링

```python
def life_insurance_survival_modeling():
    """생명보험 생존시간 모델링"""
    
    # 실제 생명보험 생존 데이터 (예시)
    life_survival = np.random.weibull(1.5, 1000) * 80  # 평균 80세
    
    # 매개변수 추정
    alpha_est, beta_est = estimate_weibull_params(life_survival)
    
    # 통계량 계산
    mean_survival = beta_est * stats.gamma(1 + 1/alpha_est)
    var_survival = beta_est**2 * (stats.gamma(1 + 2/alpha_est) - stats.gamma(1 + 1/alpha_est)**2)
    
    # VaR 계산
    var_95 = stats.weibull_min.ppf(0.05, alpha_est, scale=beta_est)
    var_99 = stats.weibull_min.ppf(0.01, alpha_est, scale=beta_est)
    
    print(f"생명보험 생존시간 분석:")
    print(f"평균 생존시간: {mean_survival:.2f}세")
    print(f"분산: {var_survival:.2f}")
    print(f"95% VaR: {var_95:.2f}세")
    print(f"99% VaR: {var_99:.2f}세")
    
    return alpha_est, beta_est, mean_survival, var_95, var_99
```

### 사례 2: 보험료 산출 시스템

```python
def weibull_premium_calculation(alpha, beta, safety_loading=0.2, confidence_level=0.95):
    """와이블분포를 활용한 보험료 산출"""
    
    # 기대 생존시간
    expected_survival = beta * stats.gamma(1 + 1/alpha)
    
    # 표준편차
    std_survival = np.sqrt(beta**2 * (stats.gamma(1 + 2/alpha) - stats.gamma(1 + 1/alpha)**2))
    
    # 안전부하
    safety_margin = safety_loading * std_survival
    
    # 리스크 부하 (VaR 기반)
    var = stats.weibull_min.ppf(1 - confidence_level, alpha, scale=beta)
    risk_loading = max(0, var - expected_survival) * 0.1
    
    # 총 보험료
    total_premium = expected_survival + safety_margin + risk_loading
    
    return {
        'expected_survival': expected_survival,
        'safety_margin': safety_margin,
        'risk_loading': risk_loading,
        'total_premium': total_premium,
        'var': var
    }

# 보험료 산출 실행
premium_result = weibull_premium_calculation(estimated_alpha, estimated_beta)
for key, value in premium_result.items():
    print(f"{key}: {value:.2f}")
```

## 와이블분포의 한계와 대안

### 1. 와이블분포의 한계

- **단일 모드**: 복잡한 생존 패턴 모델링 어려움
- **매개변수 해석**: α, β 매개변수의 직관적 해석 어려움
- **꼬리 위험**: 극단적 생존시간에 대한 과소평가 가능성

### 2. 대안 분포들

- **로그정규분포**: 더 긴 꼬리를 가진 분포
- **감마분포**: 다양한 형태의 생존 패턴 모델링
- **혼합분포**: 복잡한 생존 패턴 모델링

## 결론

와이블분포는 보험 생존시간 모델링에서 매우 유용한 도구입니다. 특히 시간에 따른 위험률 변화를 모델링할 수 있어, 보험 사고의 발생 패턴을 더 정확하게 분석할 수 있습니다.

다음 포스트에서는 로그정규분포를 활용한 보험 모델링에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Weibull Distribution](https://real-statistics.com/distributions/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
