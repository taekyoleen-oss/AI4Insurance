---
title: "지수분포를 활용한 보험 사고 간격 모델링"
date: "2025-02-02"
category: "distributions"
tags: ["지수분포", "사고간격", "모델링"]
excerpt: "지수분포의 이론적 배경과 보험 사고 간격 모델링에서의 활용법을 살펴보고, 포아송 과정과의 연관성 및 실무 적용 사례를 제공합니다."
---

지수분포(Exponential Distribution)는 보험업계에서 사고 간격 모델링에 가장 기본적으로 사용되는 분포입니다. 특히 포아송 과정(Poisson Process)과 밀접한 관련이 있어 보험 사고의 발생 패턴을 모델링하는 데 매우 유용합니다.

## 지수분포의 정의와 특성

지수분포는 하나의 매개변수 λ(위험률)를 가지는 연속확률분포입니다:

```
f(x) = λ * e^(-λx), x ≥ 0
```

여기서:
- **λ (lambda)**: 위험률 (hazard rate) 또는 역평균 (1/평균)

### 지수분포의 주요 특성

1. **지지집합**: x ≥ 0 (양의 값만)
2. **평균**: E[X] = 1/λ
3. **분산**: Var[X] = 1/λ²
4. **무기억성**: P(X > s+t | X > s) = P(X > t)
5. **포아송 과정과의 연관성**: 포아송 과정에서 사고 간격은 지수분포

## 보험업계에서의 지수분포 활용

### 1. 사고 간격 모델링

지수분포가 보험 사고 간격 모델링에 적합한 이유:

- **무기억성**: 과거 사고와 무관하게 미래 사고 발생
- **단순성**: 하나의 매개변수로 모델링 가능
- **포아송 과정**: 사고 발생이 포아송 과정을 따를 때 적합

### 2. 파이썬을 활용한 지수분포 모델링

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import pandas as pd
from scipy.optimize import minimize

# 지수분포 매개변수 추정 함수
def estimate_exponential_params(data):
    """최대우도추정법을 통한 지수분포 매개변수 추정"""
    
    # 지수분포의 최대우도추정량은 표본평균의 역수
    lambda_est = 1 / np.mean(data)
    
    return lambda_est

# 실제 사고 간격 데이터 (예시)
np.random.seed(42)
true_lambda = 0.1  # 평균 10일마다 사고 발생
accident_intervals = np.random.exponential(1/true_lambda, 100)

# 매개변수 추정
estimated_lambda = estimate_exponential_params(accident_intervals)

print(f"실제 위험률: {true_lambda}")
print(f"추정 위험률: {estimated_lambda:.4f}")
print(f"평균 사고 간격: {1/estimated_lambda:.2f}일")
```

### 3. 지수분포 적합도 검정

```python
def exponential_goodness_of_fit(data, lambda_param):
    """지수분포 적합도 검정"""
    
    # Kolmogorov-Smirnov 테스트
    ks_stat, ks_pvalue = stats.kstest(data, 
                                     lambda x: stats.expon.cdf(x, scale=1/lambda_param))
    
    # Anderson-Darling 테스트
    ad_stat, ad_critical, ad_significance = stats.anderson(data, dist='expon')
    
    print(f"Kolmogorov-Smirnov 통계량: {ks_stat:.4f}")
    print(f"KS p-value: {ks_pvalue:.4f}")
    print(f"Anderson-Darling 통계량: {ad_stat:.4f}")
    
    return ks_stat, ks_pvalue, ad_stat

# 적합도 검정 실행
ks_stat, ks_pvalue, ad_stat = exponential_goodness_of_fit(accident_intervals, estimated_lambda)
```

### 4. 시각화 및 분석

```python
def visualize_exponential_fit(data, lambda_param):
    """지수분포 적합 결과 시각화"""
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # 히스토그램과 적합된 분포
    ax1.hist(data, bins=30, density=True, alpha=0.7, color='skyblue', label='실제 데이터')
    x_range = np.linspace(0, np.max(data), 1000)
    fitted_pdf = stats.expon.pdf(x_range, scale=1/lambda_param)
    ax1.plot(x_range, fitted_pdf, 'r-', linewidth=2, label='지수분포 적합')
    ax1.set_title('지수분포 적합 결과')
    ax1.set_xlabel('사고 간격 (일)')
    ax1.set_ylabel('확률밀도')
    ax1.legend()
    
    # Q-Q 플롯
    stats.probplot(data, dist=stats.expon, sparams=(0, 1/lambda_param), plot=ax2)
    ax2.set_title('Q-Q 플롯 (지수분포)')
    
    plt.tight_layout()
    plt.show()

# 시각화 실행
visualize_exponential_fit(accident_intervals, estimated_lambda)
```

## 포아송 과정과의 연관성

### 1. 포아송 과정 모델링

```python
def poisson_process_simulation(lambda_rate, time_horizon=365):
    """포아송 과정 시뮬레이션"""
    
    # 사고 발생 시점 생성
    accident_times = []
    current_time = 0
    
    while current_time < time_horizon:
        # 다음 사고까지의 간격 (지수분포)
        interval = np.random.exponential(1/lambda_rate)
        current_time += interval
        
        if current_time < time_horizon:
            accident_times.append(current_time)
    
    return np.array(accident_times)

# 포아송 과정 시뮬레이션
accident_times = poisson_process_simulation(estimated_lambda, 365)
print(f"1년간 발생한 사고 수: {len(accident_times)}")
print(f"첫 5개 사고 발생 시점: {accident_times[:5]}")
```

### 2. 사고 간격 분석

```python
def analyze_accident_intervals(accident_times):
    """사고 간격 분석"""
    
    if len(accident_times) < 2:
        return None
    
    # 사고 간격 계산
    intervals = np.diff(accident_times)
    
    # 통계량 계산
    mean_interval = np.mean(intervals)
    std_interval = np.std(intervals)
    lambda_est = 1 / mean_interval
    
    print(f"평균 사고 간격: {mean_interval:.2f}일")
    print(f"표준편차: {std_interval:.2f}일")
    print(f"추정 위험률: {lambda_est:.4f}")
    
    return intervals, mean_interval, lambda_est

# 사고 간격 분석
if len(accident_times) > 1:
    intervals, mean_interval, lambda_est = analyze_accident_intervals(accident_times)
```

## 엑셀을 활용한 지수분포 분석

### 1. 기본 설정

```excel
A1: 위험률 (λ)
B1: 0.1
A2: 시간 범위
B2: 365
A3: 샘플 크기
B3: 1000
```

### 2. 지수분포 함수 활용

```excel
# 지수분포 확률밀도함수
A5: =EXPON.DIST(x, λ, FALSE)

# 지수분포 누적분포함수
A6: =EXPON.DIST(x, λ, TRUE)

# 지수분포 역함수
A7: =EXPON.INV(확률, λ)
```

### 3. 사고 발생 확률 계산

```excel
A10: 특정 기간 내 사고 발생 확률
B10: =1-EXPON.DIST(기간, λ, TRUE)

A11: 평균 사고 간격
B11: =1/B1

A12: 분산
B12: =1/(B1^2)
```

## 고급 분석 기법

### 1. 베이지안 추정

```python
import pymc3 as pm

def bayesian_exponential_estimation(data):
    """베이지안 방법을 통한 지수분포 매개변수 추정"""
    
    with pm.Model() as model:
        # 사전분포 설정 (감마분포)
        lambda_prior = pm.Gamma('lambda', alpha=1, beta=1)
        
        # 우도함수
        likelihood = pm.Exponential('likelihood', lam=lambda_prior, observed=data)
        
        # MCMC 샘플링
        trace = pm.sample(2000, tune=1000, cores=2)
    
    return trace

# 베이지안 추정 실행
trace = bayesian_exponential_estimation(accident_intervals)
pm.traceplot(trace)
plt.show()
```

### 2. 시간에 따른 위험률 변화

```python
def time_varying_hazard_rate():
    """시간에 따른 위험률 변화 모델링"""
    
    # 시간 구간별 위험률 추정
    time_intervals = np.linspace(0, 365, 10)
    hazard_rates = []
    
    for i in range(len(time_intervals)-1):
        start_time = time_intervals[i]
        end_time = time_intervals[i+1]
        
        # 해당 구간의 사고 수
        accidents_in_interval = np.sum((accident_times >= start_time) & 
                                      (accident_times < end_time))
        
        # 위험률 추정
        hazard_rate = accidents_in_interval / (end_time - start_time)
        hazard_rates.append(hazard_rate)
    
    return time_intervals[:-1], hazard_rates

# 시간에 따른 위험률 분석
if len(accident_times) > 0:
    time_points, hazard_rates = time_varying_hazard_rate()
    
    plt.figure(figsize=(10, 6))
    plt.plot(time_points, hazard_rates, 'o-', linewidth=2, markersize=6)
    plt.axhline(y=estimated_lambda, color='r', linestyle='--', 
                label=f'전체 평균 위험률: {estimated_lambda:.4f}')
    plt.title('시간에 따른 위험률 변화')
    plt.xlabel('시간 (일)')
    plt.ylabel('위험률')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
```

## 실무 적용 사례

### 사례 1: 자동차보험 사고 간격 모델링

```python
def auto_insurance_accident_modeling():
    """자동차보험 사고 간격 모델링"""
    
    # 실제 자동차보험 사고 데이터 (예시)
    auto_accidents = np.random.exponential(30, 200)  # 평균 30일마다 사고
    
    # 매개변수 추정
    lambda_est = estimate_exponential_params(auto_accidents)
    
    # 통계량 계산
    mean_interval = np.mean(auto_accidents)
    var_interval = np.var(auto_accidents)
    
    # VaR 계산
    var_95 = stats.expon.ppf(0.95, scale=1/lambda_est)
    var_99 = stats.expon.ppf(0.99, scale=1/lambda_est)
    
    print(f"자동차보험 사고 간격 분석:")
    print(f"평균 사고 간격: {mean_interval:.2f}일")
    print(f"분산: {var_interval:.2f}")
    print(f"95% VaR: {var_95:.2f}일")
    print(f"99% VaR: {var_99:.2f}일")
    
    return lambda_est, mean_interval, var_95, var_99
```

### 사례 2: 보험료 산출 시스템

```python
def exponential_premium_calculation(lambda_param, safety_loading=0.2, confidence_level=0.95):
    """지수분포를 활용한 보험료 산출"""
    
    # 기대 사고 간격
    expected_interval = 1 / lambda_param
    
    # 표준편차
    std_interval = 1 / lambda_param
    
    # 안전부하
    safety_margin = safety_loading * std_interval
    
    # 리스크 부하 (VaR 기반)
    var = stats.expon.ppf(confidence_level, scale=1/lambda_param)
    risk_loading = max(0, var - expected_interval) * 0.1
    
    # 총 보험료 (간격 기준)
    total_premium = expected_interval + safety_margin + risk_loading
    
    return {
        'expected_interval': expected_interval,
        'safety_margin': safety_margin,
        'risk_loading': risk_loading,
        'total_premium': total_premium,
        'var': var
    }

# 보험료 산출 실행
premium_result = exponential_premium_calculation(estimated_lambda)
for key, value in premium_result.items():
    print(f"{key}: {value:.2f}")
```

## 지수분포의 한계와 대안

### 1. 지수분포의 한계

- **무기억성**: 실제로는 과거 사고가 미래에 영향
- **단일 위험률**: 시간에 따른 위험률 변화 모델링 어려움
- **단순성**: 복잡한 사고 패턴 모델링 한계

### 2. 대안 분포들

- **와이블분포**: 시간에 따른 위험률 변화 모델링
- **감마분포**: 더 복잡한 사고 패턴 모델링
- **혼합분포**: 다양한 사고 유형 모델링

## 결론

지수분포는 보험 사고 간격 모델링에서 가장 기본적이고 중요한 분포입니다. 특히 포아송 과정과의 연관성으로 인해 보험 사고의 발생 패턴을 모델링하는 데 매우 유용합니다.

다음 포스트에서는 와이블분포와 로그정규분포를 활용한 보험 모델링에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Exponential Distribution](https://real-statistics.com/distributions/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
