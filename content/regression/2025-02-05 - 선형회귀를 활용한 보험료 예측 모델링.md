---
title: "선형회귀를 활용한 보험료 예측 모델링"
date: "2025-02-05"
category: "regression"
tags: ["선형회귀", "보험료", "예측"]
excerpt: "선형회귀의 이론적 배경과 보험료 예측에서의 활용법을 살펴보고, 엑셀과 파이썬을 활용한 실습 예제를 제공합니다."
---

선형회귀(Linear Regression)는 보험업계에서 가장 기본적이고 중요한 예측 모델 중 하나입니다. 이번 포스트에서는 선형회귀의 이론적 배경과 보험료 예측에서의 실무적 활용법을 자세히 살펴보겠습니다.

## 선형회귀의 정의와 특성

선형회귀는 종속변수와 독립변수 간의 선형 관계를 모델링하는 통계적 방법입니다:

```
Y = β₀ + β₁X₁ + β₂X₂ + ... + βₙXₙ + ε
```

여기서:
- **Y**: 종속변수 (보험료)
- **X₁, X₂, ..., Xₙ**: 독립변수 (위험요인들)
- **β₀**: 절편 (intercept)
- **β₁, β₂, ..., βₙ**: 회귀계수 (regression coefficients)
- **ε**: 오차항 (error term)

### 선형회귀의 주요 가정

1. **선형성**: 종속변수와 독립변수 간의 선형 관계
2. **독립성**: 관측값들이 서로 독립
3. **등분산성**: 오차항의 분산이 일정
4. **정규성**: 오차항이 정규분포를 따름

## 보험업계에서의 선형회귀 활용

### 1. 보험료 예측 모델

보험료 예측에서 선형회귀가 활용되는 주요 영역:

- **자동차보험**: 연령, 운전경력, 차량가격 등
- **건강보험**: 나이, 성별, 직업, 건강상태 등
- **생명보험**: 나이, 성별, 직업, 흡연여부 등

### 2. 파이썬을 활용한 선형회귀 모델링

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import seaborn as sns

# 보험 데이터 생성 (예시)
np.random.seed(42)
n_samples = 1000

# 독립변수들
age = np.random.normal(35, 10, n_samples)
driving_experience = np.random.normal(10, 5, n_samples)
car_value = np.random.normal(20000, 5000, n_samples)
claims_history = np.random.poisson(2, n_samples)

# 종속변수 (보험료) - 선형 관계 + 노이즈
premium = (50 + 2*age + 0.5*driving_experience + 0.001*car_value + 100*claims_history + 
           np.random.normal(0, 50, n_samples))

# 데이터프레임 생성
data = pd.DataFrame({
    'age': age,
    'driving_experience': driving_experience,
    'car_value': car_value,
    'claims_history': claims_history,
    'premium': premium
})

print("데이터 기본 통계:")
print(data.describe())
```

### 3. 모델 구축 및 평가

```python
def build_linear_regression_model(data):
    """선형회귀 모델 구축 및 평가"""
    
    # 특성과 타겟 분리
    X = data[['age', 'driving_experience', 'car_value', 'claims_history']]
    y = data['premium']
    
    # 훈련/테스트 데이터 분할
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # 선형회귀 모델 훈련
    model = LinearRegression()
    model.fit(X_train, y_train)
    
    # 예측
    y_pred = model.predict(X_test)
    
    # 모델 평가
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    
    print(f"평균 제곱 오차 (MSE): {mse:.2f}")
    print(f"결정계수 (R²): {r2:.4f}")
    
    # 회귀계수 출력
    feature_names = X.columns
    coefficients = model.coef_
    intercept = model.intercept_
    
    print("\n회귀계수:")
    print(f"절편: {intercept:.2f}")
    for name, coef in zip(feature_names, coefficients):
        print(f"{name}: {coef:.4f}")
    
    return model, X_test, y_test, y_pred

# 모델 구축 및 평가
model, X_test, y_test, y_pred = build_linear_regression_model(data)
```

### 4. 시각화 및 분석

```python
def visualize_regression_results(X_test, y_test, y_pred):
    """회귀 결과 시각화"""
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    
    # 실제값 vs 예측값 산점도
    ax1.scatter(y_test, y_pred, alpha=0.6)
    ax1.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
    ax1.set_xlabel('실제 보험료')
    ax1.set_ylabel('예측 보험료')
    ax1.set_title('실제값 vs 예측값')
    ax1.grid(True, alpha=0.3)
    
    # 잔차 플롯
    residuals = y_test - y_pred
    ax2.scatter(y_pred, residuals, alpha=0.6)
    ax2.axhline(y=0, color='r', linestyle='--')
    ax2.set_xlabel('예측값')
    ax2.set_ylabel('잔차')
    ax2.set_title('잔차 플롯')
    ax2.grid(True, alpha=0.3)
    
    # 잔차 히스토그램
    ax3.hist(residuals, bins=30, alpha=0.7, color='skyblue')
    ax3.set_xlabel('잔차')
    ax3.set_ylabel('빈도')
    ax3.set_title('잔차 분포')
    ax3.grid(True, alpha=0.3)
    
    # Q-Q 플롯
    from scipy import stats
    stats.probplot(residuals, dist="norm", plot=ax4)
    ax4.set_title('Q-Q 플롯 (정규성 검정)')
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# 시각화 실행
visualize_regression_results(X_test, y_test, y_pred)
```

## 엑셀을 활용한 선형회귀 분석

### 1. 기본 설정

```excel
A1: 나이
B1: 운전경력
C1: 차량가격
D1: 사고이력
E1: 보험료
```

### 2. 회귀분석 함수 활용

```excel
# LINEST 함수를 통한 회귀계수 계산
A5: =LINEST(E2:E1001, A2:D1001, TRUE, TRUE)

# 회귀계수 해석
A6: 절편 (β₀)
B6: =INDEX(LINEST(E2:E1001, A2:D1001, TRUE, TRUE), 1, 5)
A7: 나이 계수 (β₁)
B7: =INDEX(LINEST(E2:E1001, A2:D1001, TRUE, TRUE), 1, 4)
A8: 운전경력 계수 (β₂)
B8: =INDEX(LINEST(E2:E1001, A2:D1001, TRUE, TRUE), 1, 3)
A9: 차량가격 계수 (β₃)
B9: =INDEX(LINEST(E2:E1001, A2:D1001, TRUE, TRUE), 1, 2)
A10: 사고이력 계수 (β₄)
B10: =INDEX(LINEST(E2:E1001, A2:D1001, TRUE, TRUE), 1, 1)
```

### 3. 보험료 예측

```excel
A12: 새로운 고객 정보
A13: 나이: 30
B13: 운전경력: 5
C13: 차량가격: 25000
D13: 사고이력: 1

A15: 예측 보험료
B15: =B6 + B7*A13 + B8*B13 + B9*C13 + B10*D13
```

## 고급 분석 기법

### 1. 다중공선성 검정

```python
def check_multicollinearity(X):
    """다중공선성 검정"""
    
    from statsmodels.stats.outliers_influence import variance_inflation_factor
    
    # VIF 계산
    vif_data = pd.DataFrame()
    vif_data["Variable"] = X.columns
    vif_data["VIF"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]
    
    print("다중공선성 검정 (VIF):")
    print(vif_data)
    
    # VIF > 10이면 다중공선성 문제
    high_vif = vif_data[vif_data["VIF"] > 10]
    if len(high_vif) > 0:
        print("\n다중공선성 문제가 있는 변수들:")
        print(high_vif)
    else:
        print("\n다중공선성 문제 없음")
    
    return vif_data

# 다중공선성 검정
X = data[['age', 'driving_experience', 'car_value', 'claims_history']]
vif_results = check_multicollinearity(X)
```

### 2. 모델 진단

```python
def model_diagnostics(X, y, model):
    """모델 진단"""
    
    import statsmodels.api as sm
    
    # OLS 모델 구축
    X_with_const = sm.add_constant(X)
    ols_model = sm.OLS(y, X_with_const).fit()
    
    print("회귀분석 결과:")
    print(ols_model.summary())
    
    # 잔차 분석
    residuals = ols_model.resid
    fitted_values = ols_model.fittedvalues
    
    # Durbin-Watson 통계량 (자기상관 검정)
    from statsmodels.stats.diagnostic import durbin_watson
    dw_stat = durbin_watson(residuals)
    print(f"\nDurbin-Watson 통계량: {dw_stat:.4f}")
    
    if dw_stat < 1.5:
        print("자기상관 문제 가능성 있음")
    elif dw_stat > 2.5:
        print("음의 자기상관 가능성 있음")
    else:
        print("자기상관 문제 없음")
    
    return ols_model

# 모델 진단 실행
X = data[['age', 'driving_experience', 'car_value', 'claims_history']]
y = data['premium']
ols_model = model_diagnostics(X, y, model)
```

## 실무 적용 사례

### 사례 1: 자동차보험료 예측 시스템

```python
def auto_insurance_premium_prediction():
    """자동차보험료 예측 시스템"""
    
    # 실제 자동차보험 데이터 (예시)
    auto_data = pd.DataFrame({
        'age': np.random.normal(35, 10, 500),
        'driving_experience': np.random.normal(10, 5, 500),
        'car_value': np.random.normal(20000, 5000, 500),
        'claims_history': np.random.poisson(2, 500),
        'premium': np.random.normal(1000, 200, 500)
    })
    
    # 모델 구축
    X = auto_data[['age', 'driving_experience', 'car_value', 'claims_history']]
    y = auto_data['premium']
    
    model = LinearRegression()
    model.fit(X, y)
    
    # 새로운 고객 보험료 예측
    new_customer = pd.DataFrame({
        'age': [30],
        'driving_experience': [5],
        'car_value': [25000],
        'claims_history': [1]
    })
    
    predicted_premium = model.predict(new_customer)
    print(f"예측 보험료: {predicted_premium[0]:.2f}원")
    
    return model, predicted_premium

# 자동차보험료 예측 실행
auto_model, predicted_premium = auto_insurance_premium_prediction()
```

### 사례 2: 보험료 산출 시스템

```python
def premium_calculation_system(model, customer_data):
    """보험료 산출 시스템"""
    
    # 기본 보험료 계산
    base_premium = model.predict(customer_data)[0]
    
    # 안전부하 (20%)
    safety_loading = base_premium * 0.2
    
    # 총 보험료
    total_premium = base_premium + safety_loading
    
    return {
        'base_premium': base_premium,
        'safety_loading': safety_loading,
        'total_premium': total_premium
    }

# 보험료 산출 시스템 실행
customer_data = pd.DataFrame({
    'age': [30],
    'driving_experience': [5],
    'car_value': [25000],
    'claims_history': [1]
})

premium_result = premium_calculation_system(model, customer_data)
for key, value in premium_result.items():
    print(f"{key}: {value:.2f}원")
```

## 선형회귀의 한계와 대안

### 1. 선형회귀의 한계

- **선형성 가정**: 복잡한 비선형 관계 모델링 어려움
- **이상치 민감성**: 극단적 값에 대한 과도한 영향
- **다중공선성**: 독립변수 간의 상관관계 문제

### 2. 대안 모델들

- **다항회귀**: 비선형 관계 모델링
- **릿지회귀**: 다중공선성 문제 해결
- **라쏘회귀**: 변수 선택과 정규화
- **랜덤포레스트**: 비선형 관계와 복잡한 상호작용 모델링

## 결론

선형회귀는 보험업계에서 가장 기본적이고 중요한 예측 모델입니다. 특히 보험료 예측에서 독립변수들의 영향을 정량적으로 분석할 수 있어 매우 유용합니다.

다음 포스트에서는 로지스틱 회귀를 활용한 보험 사고 분류 모델링에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Regression Models](https://real-statistics.com/regression-models/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
