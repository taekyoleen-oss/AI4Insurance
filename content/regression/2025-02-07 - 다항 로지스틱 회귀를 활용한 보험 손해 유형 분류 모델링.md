---
title: "다항 로지스틱 회귀를 활용한 보험 손해 유형 분류 모델링"
date: "2025-02-07"
category: "regression"
tags: ["다항로지스틱회귀", "분류", "손해유형"]
excerpt: "다항 로지스틱 회귀의 이론적 배경과 보험 손해 유형 분류에서의 활용법을 살펴보고, 실무 적용 사례를 제공합니다."
---

다항 로지스틱 회귀(Multinomial Logistic Regression)는 보험업계에서 손해 유형을 분류하는 데 매우 유용한 모델입니다. 이번 포스트에서는 다항 로지스틱 회귀의 이론적 배경과 보험 손해 유형 분류에서의 실무적 활용법을 자세히 살펴보겠습니다.

## 다항 로지스틱 회귀의 정의와 특성

다항 로지스틱 회귀는 종속변수가 3개 이상의 범주를 가질 때 사용하는 회귀 분석 방법입니다:

```
P(Y=k|X) = e^(βₖ₀ + βₖ₁X₁ + βₖ₂X₂ + ... + βₖₙXₙ) / Σⱼ e^(βⱼ₀ + βⱼ₁X₁ + βⱼ₂X₂ + ... + βⱼₙXₙ)
```

여기서:
- **Y**: 다항 종속변수 (손해 유형: 1, 2, 3, ...)
- **X₁, X₂, ..., Xₙ**: 독립변수 (위험요인들)
- **P(Y=k|X)**: k번째 손해 유형 발생 확률
- **βₖ₀, βₖ₁, ..., βₖₙ**: k번째 손해 유형의 로지스틱 회귀계수

### 다항 로지스틱 회귀의 주요 특성

1. **다중 클래스 분류**: 3개 이상의 범주 분류 가능
2. **확률 출력**: 각 클래스별 발생 확률 제공
3. **기준 클래스**: 한 클래스를 기준으로 상대적 확률 계산
4. **해석 가능성**: 각 클래스별 오즈비를 통한 직관적 해석

## 보험업계에서의 다항 로지스틱 회귀 활용

### 1. 보험 손해 유형 분류 모델

다항 로지스틱 회귀가 보험업계에서 활용되는 주요 영역:

- **자동차보험**: 사고 유형 분류 (추돌, 측면충돌, 전복 등)
- **건강보험**: 질병 유형 분류 (심혈관, 호흡기, 소화기 등)
- **재산보험**: 손해 유형 분류 (화재, 도난, 자연재해 등)
- **해상보험**: 손해 유형 분류 (전손, 분손, 부분손 등)

### 2. 파이썬을 활용한 다항 로지스틱 회귀 모델링

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import seaborn as sns

# 보험 손해 데이터 생성 (예시)
np.random.seed(42)
n_samples = 2000

# 독립변수들
age = np.random.normal(35, 10, n_samples)
driving_experience = np.random.normal(10, 5, n_samples)
car_value = np.random.normal(20000, 5000, n_samples)
weather_risk = np.random.uniform(0, 1, n_samples)
road_condition = np.random.uniform(0, 1, n_samples)

# 손해 유형별 확률 계산
# 1: 추돌, 2: 측면충돌, 3: 전복, 4: 기타
logit_1 = (-1 + 0.02*age - 0.05*driving_experience + 0.0001*car_value + 
           0.3*weather_risk + 0.2*road_condition + np.random.normal(0, 0.3, n_samples))
logit_2 = (-0.5 + 0.03*age - 0.03*driving_experience + 0.0002*car_value + 
           0.4*weather_risk + 0.3*road_condition + np.random.normal(0, 0.3, n_samples))
logit_3 = (-2 + 0.01*age - 0.02*driving_experience + 0.0003*car_value + 
           0.5*weather_risk + 0.4*road_condition + np.random.normal(0, 0.3, n_samples))
logit_4 = (-0.8 + 0.01*age - 0.01*driving_experience + 0.0001*car_value + 
           0.2*weather_risk + 0.1*road_condition + np.random.normal(0, 0.3, n_samples))

# 소프트맥스 함수를 통한 확률 계산
exp_logits = np.exp([logit_1, logit_2, logit_3, logit_4])
probabilities = exp_logits / np.sum(exp_logits, axis=0)

# 손해 유형 생성
damage_types = np.argmax(probabilities, axis=0) + 1

# 데이터프레임 생성
data = pd.DataFrame({
    'age': age,
    'driving_experience': driving_experience,
    'car_value': car_value,
    'weather_risk': weather_risk,
    'road_condition': road_condition,
    'damage_type': damage_types
})

# 손해 유형별 분포 확인
print("손해 유형별 분포:")
print(data['damage_type'].value_counts().sort_index())
print(f"\n전체 손해 발생률: {len(data) / n_samples:.3f}")
```

### 3. 모델 구축 및 평가

```python
def build_multinomial_logistic_regression_model(data):
    """다항 로지스틱 회귀 모델 구축 및 평가"""
    
    # 특성과 타겟 분리
    X = data[['age', 'driving_experience', 'car_value', 'weather_risk', 'road_condition']]
    y = data['damage_type']
    
    # 훈련/테스트 데이터 분할
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # 다항 로지스틱 회귀 모델 훈련
    model = LogisticRegression(multi_class='multinomial', random_state=42, max_iter=1000)
    model.fit(X_train, y_train)
    
    # 예측
    y_pred = model.predict(X_test)
    y_pred_proba = model.predict_proba(X_test)
    
    # 모델 평가
    accuracy = accuracy_score(y_test, y_pred)
    print(f"정확도: {accuracy:.4f}")
    
    print("\n분류 성능 평가:")
    print(classification_report(y_test, y_pred))
    
    # 회귀계수 출력
    feature_names = X.columns
    coefficients = model.coef_
    intercepts = model.intercept_
    
    print("\n다항 로지스틱 회귀계수:")
    for i, (intercept, coef) in enumerate(zip(intercepts, coefficients)):
        print(f"\n손해 유형 {i+1} (기준: 손해 유형 4):")
        print(f"절편: {intercept:.4f}")
        for name, coef_val in zip(feature_names, coef):
            print(f"{name}: {coef_val:.4f}")
    
    return model, X_test, y_test, y_pred, y_pred_proba

# 모델 구축 및 평가
model, X_test, y_test, y_pred, y_pred_proba = build_multinomial_logistic_regression_model(data)
```

### 4. 시각화 및 분석

```python
def visualize_multinomial_logistic_regression_results(X_test, y_test, y_pred, y_pred_proba):
    """다항 로지스틱 회귀 결과 시각화"""
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    
    # 혼동 행렬
    cm = confusion_matrix(y_test, y_pred)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax1)
    ax1.set_title('혼동 행렬')
    ax1.set_xlabel('예측값')
    ax1.set_ylabel('실제값')
    
    # 클래스별 예측 확률 분포
    for i in range(4):
        ax2.hist(y_pred_proba[:, i], bins=30, alpha=0.7, label=f'손해 유형 {i+1}')
    ax2.set_xlabel('예측 확률')
    ax2.set_ylabel('빈도')
    ax2.set_title('클래스별 예측 확률 분포')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # 특성 중요도 (각 클래스별)
    feature_importance = np.abs(model.coef_)
    feature_names = X_test.columns
    x = np.arange(len(feature_names))
    width = 0.2
    
    for i in range(4):
        ax3.bar(x + i*width, feature_importance[i], width, label=f'손해 유형 {i+1}')
    
    ax3.set_xlabel('특성')
    ax3.set_ylabel('특성 중요도 (절댓값)')
    ax3.set_title('클래스별 특성 중요도')
    ax3.set_xticks(x + width * 1.5)
    ax3.set_xticklabels(feature_names)
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 예측 확률 히트맵
    prob_df = pd.DataFrame(y_pred_proba, columns=[f'손해 유형 {i+1}' for i in range(4)])
    sns.heatmap(prob_df.T, cmap='YlOrRd', ax=ax4)
    ax4.set_title('예측 확률 히트맵')
    ax4.set_xlabel('샘플')
    ax4.set_ylabel('손해 유형')
    
    plt.tight_layout()
    plt.show()

# 시각화 실행
visualize_multinomial_logistic_regression_results(X_test, y_test, y_pred, y_pred_proba)
```

## 엑셀을 활용한 다항 로지스틱 회귀 분석

### 1. 기본 설정

```excel
A1: 나이
B1: 운전경력
C1: 차량가격
D1: 날씨위험
E1: 도로상태
F1: 손해유형
```

### 2. 다항 로지스틱 회귀 확률 계산

```excel
# 각 손해 유형별 로지트 계산
A5: 로지트1 (추돌)
B5: =절편1 + 나이계수1*A2 + 운전경력계수1*B2 + 차량가격계수1*C2 + 날씨위험계수1*D2 + 도로상태계수1*E2

A6: 로지트2 (측면충돌)
B6: =절편2 + 나이계수2*A2 + 운전경력계수2*B2 + 차량가격계수2*C2 + 날씨위험계수2*D2 + 도로상태계수2*E2

A7: 로지트3 (전복)
B7: =절편3 + 나이계수3*A2 + 운전경력계수3*B2 + 차량가격계수3*C2 + 날씨위험계수3*D2 + 도로상태계수3*E2

A8: 로지트4 (기타)
B8: =절편4 + 나이계수4*A2 + 운전경력계수4*B2 + 차량가격계수4*C2 + 날씨위험계수4*D2 + 도로상태계수4*E2
```

### 3. 소프트맥스 함수 적용

```excel
# 소프트맥스 함수를 통한 확률 계산
A10: 확률1 (추돌)
B10: =EXP(B5)/(EXP(B5)+EXP(B6)+EXP(B7)+EXP(B8))

A11: 확률2 (측면충돌)
B11: =EXP(B6)/(EXP(B5)+EXP(B6)+EXP(B7)+EXP(B8))

A12: 확률3 (전복)
B12: =EXP(B7)/(EXP(B5)+EXP(B6)+EXP(B7)+EXP(B8))

A13: 확률4 (기타)
B13: =EXP(B8)/(EXP(B5)+EXP(B6)+EXP(B7)+EXP(B8))
```

## 고급 분석 기법

### 1. 클래스 불균형 처리

```python
def handle_class_imbalance(X, y):
    """클래스 불균형 처리"""
    
    from sklearn.utils.class_weight import compute_class_weight
    
    # 클래스 가중치 계산
    class_weights = compute_class_weight('balanced', classes=np.unique(y), y=y)
    class_weight_dict = dict(zip(np.unique(y), class_weights))
    
    print("클래스 가중치:")
    for class_label, weight in class_weight_dict.items():
        print(f"손해 유형 {class_label}: {weight:.4f}")
    
    # 가중치를 적용한 모델 훈련
    model_weighted = LogisticRegression(multi_class='multinomial', 
                                      class_weight=class_weight_dict,
                                      random_state=42, max_iter=1000)
    
    return model_weighted, class_weight_dict

# 클래스 불균형 처리
model_weighted, class_weight_dict = handle_class_imbalance(X, y)
```

### 2. 모델 해석

```python
def interpret_multinomial_logistic_regression(model, X, feature_names):
    """다항 로지스틱 회귀 모델 해석"""
    
    # 회귀계수와 오즈비 계산
    coefficients = model.coef_
    intercepts = model.intercept_
    
    print("모델 해석:")
    print("="*50)
    
    for i, (intercept, coef) in enumerate(zip(intercepts, coefficients)):
        print(f"\n손해 유형 {i+1} (기준: 손해 유형 4):")
        print(f"절편: {intercept:.4f}")
        
        for name, coef_val in zip(feature_names, coef):
            odds_ratio = np.exp(coef_val)
            print(f"{name}: 계수={coef_val:.4f}, 오즈비={odds_ratio:.4f}")
            
            # 해석
            if coef_val > 0:
                print(f"  → {name}이 1단위 증가할 때 손해 유형 {i+1} 발생 확률이 {odds_ratio:.2f}배 증가")
            else:
                print(f"  → {name}이 1단위 증가할 때 손해 유형 {i+1} 발생 확률이 {1/odds_ratio:.2f}배 감소")
    
    return coefficients, intercepts

# 모델 해석 실행
feature_names = X.columns
coefficients, intercepts = interpret_multinomial_logistic_regression(model, X, feature_names)
```

## 실무 적용 사례

### 사례 1: 자동차보험 손해 유형 분류 시스템

```python
def auto_insurance_damage_type_classification():
    """자동차보험 손해 유형 분류 시스템"""
    
    # 실제 자동차보험 데이터 (예시)
    auto_data = pd.DataFrame({
        'age': np.random.normal(35, 10, 1500),
        'driving_experience': np.random.normal(10, 5, 1500),
        'car_value': np.random.normal(20000, 5000, 1500),
        'weather_risk': np.random.uniform(0, 1, 1500),
        'road_condition': np.random.uniform(0, 1, 1500),
        'damage_type': np.random.choice([1, 2, 3, 4], 1500, p=[0.4, 0.3, 0.2, 0.1])
    })
    
    # 모델 구축
    X = auto_data[['age', 'driving_experience', 'car_value', 'weather_risk', 'road_condition']]
    y = auto_data['damage_type']
    
    model = LogisticRegression(multi_class='multinomial', random_state=42, max_iter=1000)
    model.fit(X, y)
    
    # 새로운 고객 손해 유형 예측
    new_customer = pd.DataFrame({
        'age': [30],
        'driving_experience': [5],
        'car_value': [25000],
        'weather_risk': [0.7],
        'road_condition': [0.8]
    })
    
    damage_type_prob = model.predict_proba(new_customer)[0]
    predicted_type = model.predict(new_customer)[0]
    
    print(f"예측 손해 유형: {predicted_type}")
    print("각 손해 유형별 확률:")
    for i, prob in enumerate(damage_type_prob):
        print(f"  손해 유형 {i+1}: {prob:.4f}")
    
    return model, damage_type_prob, predicted_type

# 자동차보험 손해 유형 분류 실행
auto_model, damage_type_prob, predicted_type = auto_insurance_damage_type_classification()
```

### 사례 2: 보험료 산출 시스템

```python
def premium_calculation_with_damage_type(model, customer_data):
    """손해 유형을 고려한 보험료 산출 시스템"""
    
    # 손해 유형별 확률 계산
    damage_type_prob = model.predict_proba(customer_data)[0]
    
    # 기본 보험료
    base_premium = 1000
    
    # 손해 유형별 보험료 계수
    damage_type_multipliers = {
        1: 1.2,  # 추돌
        2: 1.5,  # 측면충돌
        3: 2.0,  # 전복
        4: 1.0   # 기타
    }
    
    # 가중 평균 보험료 계산
    weighted_premium = sum(prob * damage_type_multipliers[i+1] for i, prob in enumerate(damage_type_prob))
    total_premium = base_premium * weighted_premium
    
    return {
        'damage_type_prob': damage_type_prob,
        'weighted_premium': weighted_premium,
        'base_premium': base_premium,
        'total_premium': total_premium
    }

# 보험료 산출 시스템 실행
customer_data = pd.DataFrame({
    'age': [30],
    'driving_experience': [5],
    'car_value': [25000],
    'weather_risk': [0.7],
    'road_condition': [0.8]
})

premium_result = premium_calculation_with_damage_type(model, customer_data)
for key, value in premium_result.items():
    print(f"{key}: {value}")
```

## 다항 로지스틱 회귀의 한계와 대안

### 1. 다항 로지스틱 회귀의 한계

- **선형 관계 가정**: 복잡한 비선형 관계 모델링 어려움
- **독립성 가정**: 변수 간의 상호작용 모델링 한계
- **클래스 불균형**: 불균형 데이터에서의 성능 저하

### 2. 대안 모델들

- **랜덤포레스트**: 비선형 관계와 복잡한 상호작용 모델링
- **XGBoost**: 클래스 불균형과 과적합 문제 해결
- **신경망**: 복잡한 비선형 관계 모델링
- **앙상블**: 여러 모델의 조합을 통한 성능 향상

## 결론

다항 로지스틱 회귀는 보험업계에서 손해 유형을 분류하는 데 매우 유용한 모델입니다. 특히 해석 가능성이 높아 보험료 산출과 위험도 평가에 직접적으로 활용할 수 있습니다.

다음 포스트에서는 순서형 로지스틱 회귀를 활용한 보험 모델링에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Regression Models](https://real-statistics.com/regression-models/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
