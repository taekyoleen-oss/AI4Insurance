---
title: "순서형 로지스틱 회귀를 활용한 보험 위험도 등급 분류 모델링"
date: "2025-02-08"
category: "regression"
tags: ["순서형로지스틱회귀", "위험도등급", "분류"]
excerpt: "순서형 로지스틱 회귀의 이론적 배경과 보험 위험도 등급 분류에서의 활용법을 살펴보고, 실무 적용 사례를 제공합니다."
---

순서형 로지스틱 회귀(Ordinal Logistic Regression)는 보험업계에서 위험도 등급을 분류하는 데 매우 유용한 모델입니다. 이번 포스트에서는 순서형 로지스틱 회귀의 이론적 배경과 보험 위험도 등급 분류에서의 실무적 활용법을 자세히 살펴보겠습니다.

## 순서형 로지스틱 회귀의 정의와 특성

순서형 로지스틱 회귀는 종속변수가 순서가 있는 범주형 변수일 때 사용하는 회귀 분석 방법입니다:

```
P(Y ≤ k|X) = 1 / (1 + e^(-(αₖ - β₁X₁ - β₂X₂ - ... - βₙXₙ)))
```

여기서:
- **Y**: 순서형 종속변수 (위험도 등급: 1, 2, 3, 4, 5)
- **X₁, X₂, ..., Xₙ**: 독립변수 (위험요인들)
- **P(Y ≤ k|X)**: k등급 이하일 확률
- **αₖ**: k번째 절단점 (cutpoint)
- **β₁, β₂, ..., βₙ**: 회귀계수 (모든 등급에 공통)

### 순서형 로지스틱 회귀의 주요 특성

1. **순서 보존**: 등급 간의 순서 관계 유지
2. **공통 회귀계수**: 모든 등급에 동일한 회귀계수 적용
3. **절단점**: 등급 간의 경계점 정의
4. **해석 가능성**: 등급별 확률과 누적 확률 제공

## 보험업계에서의 순서형 로지스틱 회귀 활용

### 1. 보험 위험도 등급 분류 모델

순서형 로지스틱 회귀가 보험업계에서 활용되는 주요 영역:

- **자동차보험**: 위험도 등급 분류 (1등급: 최저위험, 5등급: 최고위험)
- **건강보험**: 건강 위험도 등급 분류
- **생명보험**: 사망 위험도 등급 분류
- **재산보험**: 손해 위험도 등급 분류

### 2. 파이썬을 활용한 순서형 로지스틱 회귀 모델링

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import seaborn as sns

# 보험 위험도 데이터 생성 (예시)
np.random.seed(42)
n_samples = 2000

# 독립변수들
age = np.random.normal(35, 10, n_samples)
driving_experience = np.random.normal(10, 5, n_samples)
car_value = np.random.normal(20000, 5000, n_samples)
claims_history = np.random.poisson(2, n_samples)
weather_risk = np.random.uniform(0, 1, n_samples)

# 위험도 등급별 절단점 계산
# 1등급: 최저위험, 2등급: 저위험, 3등급: 중위험, 4등급: 고위험, 5등급: 최고위험
cutpoints = [-2, -1, 0, 1]  # 4개의 절단점 (5개 등급)

# 위험도 점수 계산
risk_score = (0.05*age - 0.1*driving_experience + 0.0001*car_value + 
              0.3*claims_history + 0.5*weather_risk + np.random.normal(0, 0.5, n_samples))

# 위험도 등급 생성
risk_grade = np.ones(n_samples, dtype=int)
for i, cutpoint in enumerate(cutpoints):
    risk_grade[risk_score > cutpoint] = i + 2

# 데이터프레임 생성
data = pd.DataFrame({
    'age': age,
    'driving_experience': driving_experience,
    'car_value': car_value,
    'claims_history': claims_history,
    'weather_risk': weather_risk,
    'risk_grade': risk_grade,
    'risk_score': risk_score
})

# 위험도 등급별 분포 확인
print("위험도 등급별 분포:")
print(data['risk_grade'].value_counts().sort_index())
print(f"\n평균 위험도 점수: {data['risk_score'].mean():.3f}")
```

### 3. 모델 구축 및 평가

```python
def build_ordinal_logistic_regression_model(data):
    """순서형 로지스틱 회귀 모델 구축 및 평가"""
    
    # 특성과 타겟 분리
    X = data[['age', 'driving_experience', 'car_value', 'claims_history', 'weather_risk']]
    y = data['risk_grade']
    
    # 훈련/테스트 데이터 분할
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # 순서형 로지스틱 회귀 모델 훈련
    # sklearn의 LogisticRegression을 순서형으로 사용
    model = LogisticRegression(multi_class='ovr', random_state=42, max_iter=1000)
    model.fit(X_train, y_train)
    
    # 예측
    y_pred = model.predict(X_test)
    y_pred_proba = model.predict_proba(X_test)
    
    # 모델 평가
    accuracy = accuracy_score(y_test, y_pred)
    print(f"정확도: {accuracy:.4f}")
    
    print("\n분류 성능 평가:")
    print(classification_report(y_test, y_pred))
    
    # 회귀계수 출력
    feature_names = X.columns
    coefficients = model.coef_
    intercepts = model.intercept_
    
    print("\n순서형 로지스틱 회귀계수:")
    print("공통 회귀계수:")
    for name, coef in zip(feature_names, coefficients[0]):
        print(f"{name}: {coef:.4f}")
    
    print("\n절단점 (절편):")
    for i, intercept in enumerate(intercepts):
        print(f"등급 {i+1}과 {i+2} 사이: {intercept:.4f}")
    
    return model, X_test, y_test, y_pred, y_pred_proba

# 모델 구축 및 평가
model, X_test, y_test, y_pred, y_pred_proba = build_ordinal_logistic_regression_model(data)
```

### 4. 시각화 및 분석

```python
def visualize_ordinal_logistic_regression_results(X_test, y_test, y_pred, y_pred_proba):
    """순서형 로지스틱 회귀 결과 시각화"""
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    
    # 혼동 행렬
    cm = confusion_matrix(y_test, y_pred)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax1)
    ax1.set_title('혼동 행렬')
    ax1.set_xlabel('예측값')
    ax1.set_ylabel('실제값')
    
    # 위험도 등급별 분포
    grade_counts = pd.Series(y_test).value_counts().sort_index()
    ax2.bar(grade_counts.index, grade_counts.values, alpha=0.7, color='skyblue')
    ax2.set_xlabel('위험도 등급')
    ax2.set_ylabel('빈도')
    ax2.set_title('위험도 등급별 분포')
    ax2.grid(True, alpha=0.3)
    
    # 특성별 위험도 점수 분포
    feature_names = X_test.columns
    for i, feature in enumerate(feature_names):
        ax3.scatter(X_test[feature], y_test, alpha=0.6, label=feature)
    ax3.set_xlabel('특성 값')
    ax3.set_ylabel('위험도 등급')
    ax3.set_title('특성별 위험도 등급 분포')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 예측 확률 히트맵
    prob_df = pd.DataFrame(y_pred_proba, columns=[f'등급 {i+1}' for i in range(5)])
    sns.heatmap(prob_df.T, cmap='YlOrRd', ax=ax4)
    ax4.set_title('예측 확률 히트맵')
    ax4.set_xlabel('샘플')
    ax4.set_ylabel('위험도 등급')
    
    plt.tight_layout()
    plt.show()

# 시각화 실행
visualize_ordinal_logistic_regression_results(X_test, y_test, y_pred, y_pred_proba)
```

## 엑셀을 활용한 순서형 로지스틱 회귀 분석

### 1. 기본 설정

```excel
A1: 나이
B1: 운전경력
C1: 차량가격
D1: 사고이력
E1: 날씨위험
F1: 위험도등급
```

### 2. 순서형 로지스틱 회귀 확률 계산

```excel
# 위험도 점수 계산
A5: 위험도점수
B5: =나이계수*A2 + 운전경력계수*B2 + 차량가격계수*C2 + 사고이력계수*D2 + 날씨위험계수*E2

# 각 등급별 누적 확률 계산
A7: P(등급 ≤ 1)
B7: =1/(1+EXP(-(절단점1 - B5)))

A8: P(등급 ≤ 2)
B8: =1/(1+EXP(-(절단점2 - B5)))

A9: P(등급 ≤ 3)
B9: =1/(1+EXP(-(절단점3 - B5)))

A10: P(등급 ≤ 4)
B10: =1/(1+EXP(-(절단점4 - B5)))
```

### 3. 각 등급별 확률 계산

```excel
# 각 등급별 확률 계산
A12: P(등급 = 1)
B12: =B7

A13: P(등급 = 2)
B13: =B8 - B7

A14: P(등급 = 3)
B14: =B9 - B8

A15: P(등급 = 4)
B15: =B10 - B9

A16: P(등급 = 5)
B16: =1 - B10
```

## 고급 분석 기법

### 1. 모델 진단

```python
def diagnose_ordinal_logistic_regression(model, X, y):
    """순서형 로지스틱 회귀 모델 진단"""
    
    # 예측 확률 계산
    y_pred_proba = model.predict_proba(X)
    
    # 각 등급별 예측 확률 분포
    print("각 등급별 예측 확률 분포:")
    for i in range(5):
        prob_i = y_pred_proba[:, i]
        print(f"등급 {i+1}: 평균={prob_i.mean():.4f}, 표준편차={prob_i.std():.4f}")
    
    # 위험도 등급별 특성 분석
    print("\n위험도 등급별 특성 분석:")
    for grade in range(1, 6):
        grade_data = X[y == grade]
        if len(grade_data) > 0:
            print(f"\n등급 {grade} (n={len(grade_data)}):")
            for feature in X.columns:
                mean_val = grade_data[feature].mean()
                std_val = grade_data[feature].std()
                print(f"  {feature}: 평균={mean_val:.3f}, 표준편차={std_val:.3f}")
    
    return y_pred_proba

# 모델 진단 실행
X = data[['age', 'driving_experience', 'car_value', 'claims_history', 'weather_risk']]
y = data['risk_grade']
y_pred_proba = diagnose_ordinal_logistic_regression(model, X, y)
```

### 2. 모델 해석

```python
def interpret_ordinal_logistic_regression(model, X, feature_names):
    """순서형 로지스틱 회귀 모델 해석"""
    
    # 회귀계수와 절단점
    coefficients = model.coef_[0]
    intercepts = model.intercept_
    
    print("모델 해석:")
    print("="*50)
    
    print("공통 회귀계수:")
    for name, coef in zip(feature_names, coefficients):
        print(f"{name}: {coef:.4f}")
        
        # 해석
        if coef > 0:
            print(f"  → {name}이 1단위 증가할 때 위험도 등급이 높아질 확률이 증가")
        else:
            print(f"  → {name}이 1단위 증가할 때 위험도 등급이 높아질 확률이 감소")
    
    print("\n절단점 (등급 간 경계):")
    for i, intercept in enumerate(intercepts):
        print(f"등급 {i+1}과 {i+2} 사이: {intercept:.4f}")
    
    return coefficients, intercepts

# 모델 해석 실행
feature_names = X.columns
coefficients, intercepts = interpret_ordinal_logistic_regression(model, X, feature_names)
```

## 실무 적용 사례

### 사례 1: 자동차보험 위험도 등급 분류 시스템

```python
def auto_insurance_risk_grade_classification():
    """자동차보험 위험도 등급 분류 시스템"""
    
    # 실제 자동차보험 데이터 (예시)
    auto_data = pd.DataFrame({
        'age': np.random.normal(35, 10, 2000),
        'driving_experience': np.random.normal(10, 5, 2000),
        'car_value': np.random.normal(20000, 5000, 2000),
        'claims_history': np.random.poisson(2, 2000),
        'weather_risk': np.random.uniform(0, 1, 2000),
        'risk_grade': np.random.choice([1, 2, 3, 4, 5], 2000, p=[0.1, 0.2, 0.4, 0.2, 0.1])
    })
    
    # 모델 구축
    X = auto_data[['age', 'driving_experience', 'car_value', 'claims_history', 'weather_risk']]
    y = auto_data['risk_grade']
    
    model = LogisticRegression(multi_class='ovr', random_state=42, max_iter=1000)
    model.fit(X, y)
    
    # 새로운 고객 위험도 등급 예측
    new_customer = pd.DataFrame({
        'age': [30],
        'driving_experience': [5],
        'car_value': [25000],
        'claims_history': [1],
        'weather_risk': [0.7]
    })
    
    risk_grade_prob = model.predict_proba(new_customer)[0]
    predicted_grade = model.predict(new_customer)[0]
    
    print(f"예측 위험도 등급: {predicted_grade}")
    print("각 위험도 등급별 확률:")
    for i, prob in enumerate(risk_grade_prob):
        print(f"  등급 {i+1}: {prob:.4f}")
    
    return model, risk_grade_prob, predicted_grade

# 자동차보험 위험도 등급 분류 실행
auto_model, risk_grade_prob, predicted_grade = auto_insurance_risk_grade_classification()
```

### 사례 2: 보험료 산출 시스템

```python
def premium_calculation_with_risk_grade(model, customer_data):
    """위험도 등급을 고려한 보험료 산출 시스템"""
    
    # 위험도 등급별 확률 계산
    risk_grade_prob = model.predict_proba(customer_data)[0]
    
    # 기본 보험료
    base_premium = 1000
    
    # 위험도 등급별 보험료 계수
    risk_grade_multipliers = {
        1: 0.8,   # 최저위험
        2: 1.0,   # 저위험
        3: 1.2,   # 중위험
        4: 1.5,   # 고위험
        5: 2.0    # 최고위험
    }
    
    # 가중 평균 보험료 계산
    weighted_premium = sum(prob * risk_grade_multipliers[i+1] for i, prob in enumerate(risk_grade_prob))
    total_premium = base_premium * weighted_premium
    
    return {
        'risk_grade_prob': risk_grade_prob,
        'weighted_premium': weighted_premium,
        'base_premium': base_premium,
        'total_premium': total_premium
    }

# 보험료 산출 시스템 실행
customer_data = pd.DataFrame({
    'age': [30],
    'driving_experience': [5],
    'car_value': [25000],
    'claims_history': [1],
    'weather_risk': [0.7]
})

premium_result = premium_calculation_with_risk_grade(model, customer_data)
for key, value in premium_result.items():
    print(f"{key}: {value}")
```

## 순서형 로지스틱 회귀의 한계와 대안

### 1. 순서형 로지스틱 회귀의 한계

- **선형 관계 가정**: 복잡한 비선형 관계 모델링 어려움
- **독립성 가정**: 변수 간의 상호작용 모델링 한계
- **등급 간 거리**: 등급 간의 거리가 동일하다고 가정

### 2. 대안 모델들

- **랜덤포레스트**: 비선형 관계와 복잡한 상호작용 모델링
- **XGBoost**: 클래스 불균형과 과적합 문제 해결
- **신경망**: 복잡한 비선형 관계 모델링
- **앙상블**: 여러 모델의 조합을 통한 성능 향상

## 결론

순서형 로지스틱 회귀는 보험업계에서 위험도 등급을 분류하는 데 매우 유용한 모델입니다. 특히 등급 간의 순서 관계를 유지하면서 해석 가능성이 높아 보험료 산출과 위험도 평가에 직접적으로 활용할 수 있습니다.

다음 포스트에서는 다른 회귀 모델들을 활용한 보험 모델링에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Regression Models](https://real-statistics.com/regression-models/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
