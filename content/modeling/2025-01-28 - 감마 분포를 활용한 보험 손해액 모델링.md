---
title: "감마 분포를 활용한 보험 손해액 모델링"
date: "2025-01-28"
category: "modeling"
excerpt: "최대우도추정법(MLE)을 사용하여 감마 분포의 매개변수를 추정하고, 이를 보험 손해액 모델링에 적용하는 방법을 알아보겠습니다."
tags: ["감마분포", "MLE", "보험손해"]
---

보험업계에서 손해액 분포를 모델링할 때 감마 분포는 매우 유용한 도구입니다. 이번 포스트에서는 최대우도추정법(Maximum Likelihood Estimation, MLE)을 사용하여 감마 분포의 매개변수를 추정하고, 실제 보험 손해 데이터에 적용하는 방법을 살펴보겠습니다.

## 감마 분포의 특성

### 수학적 정의
감마 분포는 두 개의 매개변수 α(형상 매개변수)와 β(척도 매개변수)를 가지는 연속 확률분포입니다.

**확률밀도함수:**
```
f(x) = (β^α / Γ(α)) * x^(α-1) * e^(-βx)
```

여기서:
- α > 0: 형상 매개변수 (shape parameter)
- β > 0: 척도 매개변수 (scale parameter)
- Γ(α): 감마 함수

### 보험업계에서의 활용
- **손해액 분포**: 보험 손해액의 분포 모델링
- **대기시간**: 사고 발생 간격 모델링
- **리스크 측정**: VaR, CVaR 계산에 활용

## 최대우도추정법(MLE) 이론

### 우도함수
n개의 독립적인 관측값 x₁, x₂, ..., xₙ에 대해 우도함수는:

```
L(α,β) = ∏(i=1 to n) f(xᵢ|α,β)
```

### 로그우도함수
```
ln L(α,β) = nα ln β - n ln Γ(α) + (α-1)∑ln xᵢ - β∑xᵢ
```

### MLE 추정방정식
α와 β에 대한 편미분을 0으로 설정:

```
∂ln L/∂α = n ln β - n ψ(α) + ∑ln xᵢ = 0
∂ln L/∂β = nα/β - ∑xᵢ = 0
```

여기서 ψ(α)는 디감마 함수입니다.

## R을 활용한 구현

### 1. 데이터 준비
```r
# 보험 손해액 데이터 생성 (실제 데이터로 대체)
set.seed(123)
loss_data <- rgamma(1000, shape = 2.5, scale = 1000)

# 기본 통계
summary(loss_data)
hist(loss_data, breaks = 50, main = "보험 손해액 분포")
```

### 2. MLE 구현
```r
# 감마 분포 MLE 함수
gamma_mle <- function(data) {
  n <- length(data)
  
  # 초기값 설정
  alpha_init <- mean(data)^2 / var(data)
  beta_init <- var(data) / mean(data)
  
  # 로그우도함수
  log_likelihood <- function(params) {
    alpha <- params[1]
    beta <- params[2]
    
    if (alpha <= 0 || beta <= 0) return(-Inf)
    
    n * alpha * log(beta) - n * lgamma(alpha) + 
    (alpha - 1) * sum(log(data)) - beta * sum(data)
  }
  
  # 최적화
  result <- optim(c(alpha_init, beta_init), 
                  function(x) -log_likelihood(x),
                  method = "L-BFGS-B",
                  lower = c(0.001, 0.001))
  
  return(list(
    alpha = result$par[1],
    beta = result$par[2],
    log_likelihood = -result$value
  ))
}

# MLE 추정
mle_result <- gamma_mle(loss_data)
print(mle_result)
```

### 3. 모델 검증
```r
# 적합도 검정
library(fitdistrplus)

# Kolmogorov-Smirnov 검정
ks_test <- ks.test(loss_data, "pgamma", 
                   shape = mle_result$alpha, 
                   scale = mle_result$beta)
print(ks_test)

# 시각적 검증
plot(fitdist(loss_data, "gamma"))
```

## Python을 활용한 구현

### 1. 필요한 라이브러리
```python
import numpy as np
import scipy.stats as stats
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import pandas as pd
```

### 2. MLE 구현
```python
def gamma_mle(data):
    """감마 분포 MLE 추정"""
    n = len(data)
    
    def neg_log_likelihood(params):
        alpha, beta = params
        if alpha <= 0 or beta <= 0:
            return np.inf
        
        return -(n * alpha * np.log(beta) - n * stats.gamma.logpdf(0, alpha) + 
                (alpha - 1) * np.sum(np.log(data)) - beta * np.sum(data))
    
    # 초기값
    alpha_init = np.mean(data)**2 / np.var(data)
    beta_init = np.var(data) / np.mean(data)
    
    # 최적화
    result = minimize(neg_log_likelihood, [alpha_init, beta_init], 
                      method='L-BFGS-B', bounds=[(0.001, None), (0.001, None)])
    
    return {
        'alpha': result.x[0],
        'beta': result.x[1],
        'log_likelihood': -result.fun
    }

# 데이터 생성 및 추정
np.random.seed(123)
loss_data = np.random.gamma(2.5, 1000, 1000)

mle_result = gamma_mle(loss_data)
print(f"추정된 α: {mle_result['alpha']:.4f}")
print(f"추정된 β: {mle_result['beta']:.4f}")
```

### 3. 시각화 및 검증
```python
# 히스토그램과 적합된 분포 비교
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.hist(loss_data, bins=50, density=True, alpha=0.7, label='실제 데이터')
x = np.linspace(0, max(loss_data), 1000)
plt.plot(x, stats.gamma.pdf(x, mle_result['alpha'], scale=mle_result['beta']), 
         'r-', label='적합된 감마분포')
plt.xlabel('손해액')
plt.ylabel('밀도')
plt.legend()
plt.title('감마분포 적합 결과')

# Q-Q 플롯
plt.subplot(1, 2, 2)
stats.probplot(loss_data, dist=stats.gamma, 
               sparams=(mle_result['alpha'], 0, mle_result['beta']), plot=plt)
plt.title('Q-Q 플롯')
plt.tight_layout()
plt.show()
```

## 보험 실무 적용

### 1. 손해액 예측
```python
def predict_loss_percentile(alpha, beta, percentile):
    """특정 백분위수에서의 손해액 예측"""
    return stats.gamma.ppf(percentile, alpha, scale=beta)

# 95% VaR 계산
var_95 = predict_loss_percentile(mle_result['alpha'], mle_result['beta'], 0.95)
print(f"95% VaR: {var_95:,.0f}원")

# 99% VaR 계산
var_99 = predict_loss_percentile(mle_result['alpha'], mle_result['beta'], 0.99)
print(f"99% VaR: {var_99:,.0f}원")
```

### 2. 보험료 산출
```python
def calculate_premium(alpha, beta, loading_factor=0.3):
    """감마분포 기반 보험료 산출"""
    expected_loss = alpha * beta  # 평균 손해액
    premium = expected_loss * (1 + loading_factor)
    return premium

premium = calculate_premium(mle_result['alpha'], mle_result['beta'])
print(f"산출된 보험료: {premium:,.0f}원")
```

### 3. 리스크 측정
```python
def calculate_cvar(alpha, beta, confidence_level=0.95):
    """조건부 VaR (CVaR) 계산"""
    var = stats.gamma.ppf(confidence_level, alpha, scale=beta)
    
    # CVaR = E[X | X > VaR]
    def integrand(x):
        return x * stats.gamma.pdf(x, alpha, scale=beta)
    
    from scipy.integrate import quad
    numerator, _ = quad(integrand, var, np.inf)
    denominator = 1 - confidence_level
    
    return numerator / denominator

cvar_95 = calculate_cvar(mle_result['alpha'], mle_result['beta'])
print(f"95% CVaR: {cvar_95:,.0f}원")
```

## 고급 분석 기법

### 1. 베이지안 추정
```python
import pymc3 as pm
import theano.tensor as tt

# 베이지안 감마분포 모델링
with pm.Model() as gamma_model:
    # 사전분포
    alpha_prior = pm.Gamma('alpha', alpha=1, beta=1)
    beta_prior = pm.Gamma('beta', alpha=1, beta=1)
    
    # 우도
    likelihood = pm.Gamma('likelihood', alpha=alpha_prior, beta=beta_prior, observed=loss_data)
    
    # MCMC 샘플링
    trace = pm.sample(2000, tune=1000, cores=2)

# 결과 분석
pm.plot_trace(trace)
pm.summary(trace)
```

### 2. 모델 비교
```python
from scipy.stats import lognorm, weibull_min

# 여러 분포 비교
distributions = {
    'Gamma': stats.gamma,
    'Lognormal': stats.lognorm,
    'Weibull': stats.weibull_min
}

results = {}
for name, dist in distributions.items():
    if name == 'Gamma':
        params = dist.fit(loss_data)
        log_likelihood = np.sum(dist.logpdf(loss_data, *params))
    elif name == 'Lognormal':
        params = dist.fit(loss_data, floc=0)
        log_likelihood = np.sum(dist.logpdf(loss_data, *params))
    else:
        params = dist.fit(loss_data, floc=0)
        log_likelihood = np.sum(dist.logpdf(loss_data, *params))
    
    results[name] = {
        'params': params,
        'log_likelihood': log_likelihood,
        'aic': -2 * log_likelihood + 2 * len(params)
    }

# AIC 기준 모델 선택
best_model = min(results.keys(), key=lambda x: results[x]['aic'])
print(f"최적 모델: {best_model}")
print(f"AIC: {results[best_model]['aic']:.2f}")
```

## 실무 적용 시 주의사항

### 1. 데이터 품질
- **이상값 처리**: 극값이 모델에 미치는 영향 고려
- **결측값**: 적절한 대체 방법 선택
- **표본 크기**: 충분한 데이터 확보

### 2. 모델 검증
- **적합도 검정**: KS, Anderson-Darling 검정
- **시각적 검증**: Q-Q 플롯, 히스토그램 비교
- **교차검증**: 시간적 안정성 확인

### 3. 해석 및 활용
- **비즈니스 해석**: 통계적 결과의 실무적 의미
- **불확실성**: 신뢰구간 고려
- **모델 업데이트**: 새로운 데이터 반영

## 결론

감마 분포를 활용한 보험 손해액 모델링은 [Real Statistics의 MLE 방법론](https://real-statistics.com/distribution-fitting/distribution-fitting-via-maximum-likelihood/fitting-gamma-parameters-mle/)을 기반으로 하여 보험업계에서 매우 유용한 도구입니다.

> "정확한 분포 모델링은 보험 리스크 관리의 핵심이며, MLE는 이를 위한 가장 강력한 방법 중 하나입니다."

앞으로 더 복잡한 분포 모델링과 베이지안 접근법에 대해 다루어보겠습니다.
