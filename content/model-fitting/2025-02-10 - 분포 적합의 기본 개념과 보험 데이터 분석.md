---
title: "분포 적합의 기본 개념과 보험 데이터 분석"
date: "2025-02-10"
category: "model-fitting"
tags: ["분포적합", "데이터분석", "보험모델링"]
excerpt: "분포 적합의 이론적 배경과 보험 데이터 분석에서의 활용법을 살펴보고, 실무 적용 사례를 제공합니다."
---

분포 적합(Distribution Fitting)은 보험업계에서 데이터의 분포를 파악하고 모델링하는 핵심 기법입니다. 이번 포스트에서는 분포 적합의 기본 개념과 보험 데이터 분석에서의 실무적 활용법을 자세히 살펴보겠습니다.

## 분포 적합의 정의와 목적

분포 적합은 주어진 데이터가 특정 확률분포를 따르는지 확인하고, 가장 적합한 분포를 찾는 과정입니다:

### 1. 분포 적합의 목적

- **데이터 이해**: 데이터의 특성과 패턴 파악
- **모델링**: 적절한 확률분포 모델 선택
- **예측**: 미래 값의 예측 및 시뮬레이션
- **리스크 평가**: 위험도 정량화 및 관리

### 2. 분포 적합 과정

```
1. 데이터 수집 및 전처리
2. 시각적 탐색 (히스토그램, Q-Q 플롯)
3. 분포 후보 선정
4. 모수 추정 (최대우도법, 모멘트법)
5. 적합도 검정 (Kolmogorov-Smirnov, Anderson-Darling)
6. 최적 분포 선택
```

## 보험업계에서의 분포 적합 활용

### 1. 주요 활용 영역

- **손해액 분석**: 보험 손해액의 분포 모델링
- **사고 빈도**: 사고 발생 빈도의 분포 분석
- **생존시간**: 생명보험에서의 생존시간 모델링
- **재해 분석**: 자연재해 손해액 분포 분석

### 2. 파이썬을 활용한 분포 적합

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from scipy.stats import norm, gamma, expon, weibull_min, lognorm
from sklearn.model_selection import train_test_split
import warnings
warnings.filterwarnings('ignore')

# 보험 손해액 데이터 생성 (예시)
np.random.seed(42)
n_samples = 1000

# 실제 보험 데이터 시뮬레이션
# 정규분포 + 이상치
normal_data = np.random.normal(5000, 1000, 800)
outliers = np.random.normal(15000, 3000, 200)
damage_data = np.concatenate([normal_data, outliers])

# 데이터프레임 생성
data = pd.DataFrame({
    'damage_amount': damage_data,
    'claim_type': ['normal'] * 800 + ['severe'] * 200
})

print("보험 손해액 데이터 기본 통계:")
print(data['damage_amount'].describe())
```

### 3. 시각적 탐색

```python
def exploratory_data_analysis(data):
    """탐색적 데이터 분석"""
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    
    # 히스토그램
    ax1.hist(data['damage_amount'], bins=50, alpha=0.7, color='skyblue', density=True)
    ax1.set_title('손해액 분포 히스토그램')
    ax1.set_xlabel('손해액')
    ax1.set_ylabel('밀도')
    ax1.grid(True, alpha=0.3)
    
    # 박스플롯
    ax2.boxplot(data['damage_amount'])
    ax2.set_title('손해액 박스플롯')
    ax2.set_ylabel('손해액')
    ax2.grid(True, alpha=0.3)
    
    # Q-Q 플롯 (정규분포)
    stats.probplot(data['damage_amount'], dist="norm", plot=ax3)
    ax3.set_title('Q-Q 플롯 (정규분포)')
    ax3.grid(True, alpha=0.3)
    
    # 누적분포함수
    sorted_data = np.sort(data['damage_amount'])
    y = np.arange(1, len(sorted_data) + 1) / len(sorted_data)
    ax4.plot(sorted_data, y, 'b-', linewidth=2)
    ax4.set_title('경험적 누적분포함수')
    ax4.set_xlabel('손해액')
    ax4.set_ylabel('누적확률')
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# 탐색적 데이터 분석 실행
exploratory_data_analysis(data)
```

## 분포 적합 방법론

### 1. 모멘트법 (Method of Moments)

```python
def method_of_moments(data):
    """모멘트법을 통한 분포 적합"""
    
    # 표본 모멘트 계산
    mean = np.mean(data)
    var = np.var(data, ddof=1)
    skew = stats.skew(data)
    kurt = stats.kurtosis(data)
    
    print("표본 모멘트:")
    print(f"평균: {mean:.2f}")
    print(f"분산: {var:.2f}")
    print(f"왜도: {skew:.2f}")
    print(f"첨도: {kurt:.2f}")
    
    # 정규분포 적합
    norm_params = stats.norm.fit(data)
    print(f"\n정규분포 모수: μ={norm_params[0]:.2f}, σ={norm_params[1]:.2f}")
    
    # 감마분포 적합
    gamma_params = stats.gamma.fit(data)
    print(f"감마분포 모수: shape={gamma_params[0]:.2f}, scale={gamma_params[2]:.2f}")
    
    return norm_params, gamma_params

# 모멘트법 실행
norm_params, gamma_params = method_of_moments(data['damage_amount'])
```

### 2. 최대우도법 (Maximum Likelihood Estimation)

```python
def maximum_likelihood_estimation(data):
    """최대우도법을 통한 분포 적합"""
    
    # 여러 분포에 대한 MLE
    distributions = {
        '정규분포': stats.norm,
        '감마분포': stats.gamma,
        '지수분포': stats.expon,
        '로그정규분포': stats.lognorm,
        '와이블분포': stats.weibull_min
    }
    
    results = {}
    
    for name, dist in distributions.items():
        try:
            # MLE 파라미터 추정
            params = dist.fit(data)
            
            # 로그우도 계산
            log_likelihood = np.sum(dist.logpdf(data, *params))
            
            # AIC 계산
            n_params = len(params)
            aic = 2 * n_params - 2 * log_likelihood
            
            results[name] = {
                'params': params,
                'log_likelihood': log_likelihood,
                'aic': aic
            }
            
            print(f"{name}: AIC={aic:.2f}, Log-Likelihood={log_likelihood:.2f}")
            
        except Exception as e:
            print(f"{name} 적합 실패: {e}")
    
    return results

# 최대우도법 실행
mle_results = maximum_likelihood_estimation(data['damage_amount'])
```

### 3. 적합도 검정

```python
def goodness_of_fit_tests(data, dist_name, params):
    """적합도 검정"""
    
    # 분포 객체 생성
    if dist_name == '정규분포':
        dist = stats.norm
    elif dist_name == '감마분포':
        dist = stats.gamma
    elif dist_name == '지수분포':
        dist = stats.expon
    elif dist_name == '로그정규분포':
        dist = stats.lognorm
    elif dist_name == '와이블분포':
        dist = stats.weibull_min
    
    # Kolmogorov-Smirnov 검정
    ks_stat, ks_pvalue = stats.kstest(data, lambda x: dist.cdf(x, *params))
    
    # Anderson-Darling 검정
    ad_stat, ad_critical, ad_significance = stats.anderson(data, dist.name)
    
    # Chi-square 검정
    observed, bins = np.histogram(data, bins=20)
    expected = dist.pdf(bins[:-1], *params) * len(data) * np.diff(bins)
    chi2_stat, chi2_pvalue = stats.chisquare(observed, expected)
    
    print(f"\n{dist_name} 적합도 검정 결과:")
    print(f"Kolmogorov-Smirnov: 통계량={ks_stat:.4f}, p-value={ks_pvalue:.4f}")
    print(f"Anderson-Darling: 통계량={ad_stat:.4f}")
    print(f"Chi-square: 통계량={chi2_stat:.4f}, p-value={chi2_pvalue:.4f}")
    
    return {
        'ks_stat': ks_stat,
        'ks_pvalue': ks_pvalue,
        'ad_stat': ad_stat,
        'chi2_stat': chi2_stat,
        'chi2_pvalue': chi2_pvalue
    }

# 적합도 검정 실행
best_dist = min(mle_results.items(), key=lambda x: x[1]['aic'])
print(f"\n최적 분포: {best_dist[0]} (AIC: {best_dist[1]['aic']:.2f})")

# 최적 분포에 대한 적합도 검정
goodness_results = goodness_of_fit_tests(
    data['damage_amount'], 
    best_dist[0], 
    best_dist[1]['params']
)
```

## 엑셀을 활용한 분포 적합

### 1. 기본 통계 계산

```excel
A1: 손해액
B1: 순위
C1: 누적확률

A2: =RAND()*10000+1000
B2: =RANK(A2,$A$2:$A$1001)
C2: =B2/1000
```

### 2. 분포 적합 함수

```excel
# 정규분포 적합
A5: 평균
B5: =AVERAGE(A2:A1001)
A6: 표준편차
B6: =STDEV(A2:A1001)

# 감마분포 적합
A8: 모양모수
B8: =VAR(A2:A1001)/AVERAGE(A2:A1001)
A9: 척도모수
B9: =AVERAGE(A2:A1001)/B8
```

### 3. 적합도 검정

```excel
# Kolmogorov-Smirnov 검정
A12: KS 통계량
B12: =MAX(ABS(C2:C1001-NORMDIST(A2:A1001,B5,B6,TRUE)))

# Chi-square 검정
A15: 기댓값
B15: =NORMDIST(A2,B5,B6,TRUE)*1000
A16: 관측값
B16: =COUNTIF(A2:A1001,"<="&A2)
A17: Chi-square
B17: =SUM((B16-B15)^2/B15)
```

## 고급 분석 기법

### 1. 혼합분포 모델링

```python
def mixture_distribution_modeling(data):
    """혼합분포 모델링"""
    
    from sklearn.mixture import GaussianMixture
    
    # 데이터 정규화
    data_normalized = (data - np.mean(data)) / np.std(data)
    
    # 혼합분포 모델 적합
    gmm = GaussianMixture(n_components=2, random_state=42)
    gmm.fit(data_normalized.reshape(-1, 1))
    
    # 모델 파라미터
    means = gmm.means_.flatten() * np.std(data) + np.mean(data)
    covariances = gmm.covariances_.flatten() * np.var(data)
    weights = gmm.weights_
    
    print("혼합분포 모델 파라미터:")
    for i, (mean, cov, weight) in enumerate(zip(means, covariances, weights)):
        print(f"성분 {i+1}: 평균={mean:.2f}, 분산={cov:.2f}, 가중치={weight:.3f}")
    
    return gmm, means, covariances, weights

# 혼합분포 모델링 실행
gmm, means, covariances, weights = mixture_distribution_modeling(data['damage_amount'])
```

### 2. 베이지안 분포 적합

```python
def bayesian_distribution_fitting(data):
    """베이지안 분포 적합"""
    
    import pymc3 as pm
    import theano.tensor as tt
    
    with pm.Model() as model:
        # 사전분포 설정
        mu = pm.Normal('mu', mu=0, sigma=1000)
        sigma = pm.HalfNormal('sigma', sigma=1000)
        
        # 가능도 함수
        likelihood = pm.Normal('likelihood', mu=mu, sigma=sigma, observed=data)
        
        # MCMC 샘플링
        trace = pm.sample(1000, tune=1000, random_seed=42)
    
    # 사후분포 요약
    summary = pm.summary(trace)
    print("베이지안 분포 적합 결과:")
    print(summary)
    
    return trace, summary

# 베이지안 분포 적합 실행 (데이터가 클 경우)
# trace, summary = bayesian_distribution_fitting(data['damage_amount'][:100])
```

## 실무 적용 사례

### 사례 1: 자동차보험 손해액 분포 적합

```python
def auto_insurance_damage_fitting():
    """자동차보험 손해액 분포 적합"""
    
    # 실제 자동차보험 데이터 (예시)
    np.random.seed(42)
    n_samples = 2000
    
    # 정규분포 + 이상치
    normal_damage = np.random.normal(3000, 800, 1500)
    severe_damage = np.random.normal(12000, 2000, 500)
    damage_data = np.concatenate([normal_damage, severe_damage])
    
    # 분포 적합
    distributions = {
        '정규분포': stats.norm,
        '감마분포': stats.gamma,
        '로그정규분포': stats.lognorm
    }
    
    best_fit = None
    best_aic = float('inf')
    
    for name, dist in distributions.items():
        try:
            params = dist.fit(damage_data)
            log_likelihood = np.sum(dist.logpdf(damage_data, *params))
            aic = 2 * len(params) - 2 * log_likelihood
            
            if aic < best_aic:
                best_aic = aic
                best_fit = (name, params, aic)
                
            print(f"{name}: AIC={aic:.2f}")
            
        except Exception as e:
            print(f"{name} 적합 실패: {e}")
    
    print(f"\n최적 분포: {best_fit[0]} (AIC: {best_fit[1]:.2f})")
    
    return best_fit

# 자동차보험 손해액 분포 적합 실행
best_fit = auto_insurance_damage_fitting()
```

### 사례 2: 보험료 산출 시스템

```python
def premium_calculation_with_distribution_fitting(model, customer_data):
    """분포 적합을 통한 보험료 산출 시스템"""
    
    # 예측 손해액 분포
    if model[0] == '정규분포':
        predicted_damage = stats.norm.rvs(*model[1], size=1000)
    elif model[0] == '감마분포':
        predicted_damage = stats.gamma.rvs(*model[1], size=1000)
    elif model[0] == '로그정규분포':
        predicted_damage = stats.lognorm.rvs(*model[1], size=1000)
    
    # 위험도 평가
    risk_percentile = np.percentile(predicted_damage, 95)
    expected_damage = np.mean(predicted_damage)
    
    # 보험료 계산
    base_premium = expected_damage * 0.1
    risk_loading = (risk_percentile - expected_damage) * 0.05
    total_premium = base_premium + risk_loading
    
    return {
        'expected_damage': expected_damage,
        'risk_percentile': risk_percentile,
        'base_premium': base_premium,
        'risk_loading': risk_loading,
        'total_premium': total_premium
    }

# 보험료 산출 시스템 실행
customer_data = {'age': 30, 'driving_experience': 5}
premium_result = premium_calculation_with_distribution_fitting(best_fit, customer_data)
for key, value in premium_result.items():
    print(f"{key}: {value:.2f}")
```

## 분포 적합의 한계와 대안

### 1. 분포 적합의 한계

- **분포 가정**: 특정 분포 형태 가정 필요
- **모수 추정**: 제한된 모수로 복잡한 분포 모델링 어려움
- **이상치 민감성**: 극단적 값에 대한 과도한 영향

### 2. 대안 방법들

- **비모수 방법**: 히스토그램, 커널 밀도 추정
- **머신러닝**: 랜덤포레스트, 신경망
- **베이지안 방법**: 불확실성 정량화
- **앙상블**: 여러 분포의 조합

## 결론

분포 적합은 보험업계에서 데이터의 특성을 파악하고 모델링하는 핵심 기법입니다. 특히 손해액 예측, 리스크 평가, 보험료 산출에 직접적으로 활용할 수 있습니다.

다음 포스트에서는 최대우도법을 활용한 분포 적합에 대해 자세히 살펴보겠습니다.

## 참고자료

- [Real Statistics - Distribution Fitting](https://real-statistics.com/distribution-fitting/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
