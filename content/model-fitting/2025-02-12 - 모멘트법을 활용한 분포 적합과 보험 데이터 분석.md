---
title: "모멘트법을 활용한 분포 적합과 보험 데이터 분석"
date: "2025-02-12"
category: "model-fitting"
tags: ["모멘트법", "분포적합", "보험데이터"]
excerpt: "모멘트법의 이론적 배경과 보험 데이터 분석에서의 활용법을 살펴보고, 실무 적용 사례를 제공합니다."
---

모멘트법(Method of Moments)은 분포 적합에서 가장 직관적이고 이해하기 쉬운 방법 중 하나입니다. 이번 포스트에서는 모멘트법의 이론적 배경과 보험 데이터 분석에서의 실무적 활용법을 자세히 살펴보겠습니다.

## 모멘트법의 정의와 원리

모멘트법은 표본 모멘트와 이론적 모멘트를 일치시키는 방법입니다:

### 1. 모멘트의 정의

**k차 원시 모멘트 (Raw Moment)**:
```
μₖ = E[Xᵏ] = ∫ xᵏ f(x) dx
```

**k차 중심 모멘트 (Central Moment)**:
```
μₖ' = E[(X - μ)ᵏ] = ∫ (x - μ)ᵏ f(x) dx
```

### 2. 표본 모멘트

**k차 표본 원시 모멘트**:
```
mₖ = (1/n) ∑ᵢ₌₁ⁿ xᵢᵏ
```

**k차 표본 중심 모멘트**:
```
mₖ' = (1/n) ∑ᵢ₌₁ⁿ (xᵢ - x̄)ᵏ
```

### 3. 모멘트법의 원리

```
E[Xᵏ] = mₖ  (k = 1, 2, ..., p)
```

여기서 p는 모수의 개수입니다.

## 보험업계에서의 모멘트법 활용

### 1. 주요 활용 영역

- **손해액 분석**: 보험 손해액 분포의 모수 추정
- **사고 빈도**: 사고 발생 빈도의 모수 추정
- **생존시간**: 생명보험에서의 생존시간 모델링
- **재해 분석**: 자연재해 손해액 분포 분석

### 2. 파이썬을 활용한 모멘트법 구현

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats
from scipy.stats import norm, gamma, expon, weibull_min, lognorm
import warnings
warnings.filterwarnings('ignore')

# 보험 손해액 데이터 생성 (예시)
np.random.seed(42)
n_samples = 1000

# 정규분포에서 생성된 데이터
mu_true = 5000
sigma_true = 1000
damage_data = np.random.normal(mu_true, sigma_true, n_samples)

print("보험 손해액 데이터 기본 통계:")
print(f"평균: {np.mean(damage_data):.2f}")
print(f"분산: {np.var(damage_data, ddof=1):.2f}")
print(f"왜도: {stats.skew(damage_data):.2f}")
print(f"첨도: {stats.kurtosis(damage_data):.2f}")
```

### 3. 모멘트법 구현

```python
def method_of_moments_normal(data):
    """정규분포의 모멘트법"""
    
    # 1차 모멘트 (평균)
    mu = np.mean(data)
    
    # 2차 중심 모멘트 (분산)
    sigma_squared = np.var(data, ddof=1)
    sigma = np.sqrt(sigma_squared)
    
    return mu, sigma

def method_of_moments_gamma(data):
    """감마분포의 모멘트법"""
    
    # 1차 모멘트 (평균)
    mean = np.mean(data)
    
    # 2차 중심 모멘트 (분산)
    variance = np.var(data, ddof=1)
    
    # 감마분포 모수 계산
    # E[X] = αβ, Var[X] = αβ²
    # α = E[X]² / Var[X], β = Var[X] / E[X]
    alpha = mean**2 / variance
    beta = variance / mean
    
    return alpha, beta

def method_of_moments_exponential(data):
    """지수분포의 모멘트법"""
    
    # 1차 모멘트 (평균)
    mean = np.mean(data)
    
    # 지수분포 모수 계산
    # E[X] = 1/λ, λ = 1/E[X]
    lambda_param = 1 / mean
    
    return lambda_param

def method_of_moments_lognormal(data):
    """로그정규분포의 모멘트법"""
    
    # 로그 변환
    log_data = np.log(data)
    
    # 1차 모멘트 (평균)
    mu = np.mean(log_data)
    
    # 2차 중심 모멘트 (분산)
    sigma_squared = np.var(log_data, ddof=1)
    sigma = np.sqrt(sigma_squared)
    
    return mu, sigma

# 모멘트법 실행
normal_params = method_of_moments_normal(damage_data)
gamma_params = method_of_moments_gamma(damage_data)
exp_params = method_of_moments_exponential(damage_data)
lognormal_params = method_of_moments_lognormal(damage_data)

print(f"\n정규분포 모멘트법: μ={normal_params[0]:.2f}, σ={normal_params[1]:.2f}")
print(f"감마분포 모멘트법: α={gamma_params[0]:.2f}, β={gamma_params[1]:.2f}")
print(f"지수분포 모멘트법: λ={exp_params:.2f}")
print(f"로그정규분포 모멘트법: μ={lognormal_params[0]:.2f}, σ={lognormal_params[1]:.2f}")
```

### 4. 모델 비교

```python
def model_comparison_moments(data, models):
    """모멘트법 모델 비교"""
    
    results = {}
    
    for name, params in models.items():
        if params is not None:
            # 분포 객체 생성
            if name == '정규분포':
                dist = stats.norm
                rv = dist(params[0], params[1])
            elif name == '감마분포':
                dist = stats.gamma
                rv = dist(params[0], scale=params[1])
            elif name == '지수분포':
                dist = stats.expon
                rv = dist(scale=params)
            elif name == '로그정규분포':
                dist = stats.lognorm
                rv = dist(params[1], scale=np.exp(params[0]))
            
            # 로그우도 계산
            log_likelihood = np.sum(rv.logpdf(data))
            
            # AIC 계산
            n_params = len(params) if isinstance(params, (list, tuple)) else 1
            aic = 2 * n_params - 2 * log_likelihood
            
            results[name] = {
                'params': params,
                'log_likelihood': log_likelihood,
                'aic': aic
            }
            
            print(f"{name}:")
            print(f"  Log-Likelihood: {log_likelihood:.2f}")
            print(f"  AIC: {aic:.2f}")
    
    return results

# 모델 비교 실행
models = {
    '정규분포': normal_params,
    '감마분포': gamma_params,
    '지수분포': exp_params,
    '로그정규분포': lognormal_params
}

comparison_results = model_comparison_moments(damage_data, models)
```

## 엑셀을 활용한 모멘트법

### 1. 기본 설정

```excel
A1: 손해액
B1: 로그손해액
C1: 제곱손해액

A2: =RAND()*5000+1000
B2: =LN(A2)
C2: =A2^2
```

### 2. 모멘트 계산

```excel
# 1차 모멘트 (평균)
A5: 평균
B5: =AVERAGE(A2:A1001)

# 2차 모멘트 (분산)
A6: 분산
B6: =VAR(A2:A1001)

# 3차 모멘트 (왜도)
A7: 왜도
B7: =SKEW(A2:A1001)

# 4차 모멘트 (첨도)
A8: 첨도
B8: =KURT(A2:A1001)
```

### 3. 분포별 모수 계산

```excel
# 정규분포 모수
A10: 정규분포
A11: 평균
B11: =B5
A12: 표준편차
B12: =SQRT(B6)

# 감마분포 모수
A14: 감마분포
A15: 모양모수
B15: =B5^2/B6
A16: 척도모수
B16: =B6/B5

# 지수분포 모수
A18: 지수분포
A19: 척도모수
B19: =B5
```

## 고급 분석 기법

### 1. 가중 모멘트법

```python
def weighted_method_of_moments(data, weights):
    """가중 모멘트법"""
    
    # 가중 평균
    weighted_mean = np.average(data, weights=weights)
    
    # 가중 분산
    weighted_variance = np.average((data - weighted_mean)**2, weights=weights)
    
    # 가중 왜도
    weighted_skew = np.average(((data - weighted_mean) / np.sqrt(weighted_variance))**3, weights=weights)
    
    # 가중 첨도
    weighted_kurt = np.average(((data - weighted_mean) / np.sqrt(weighted_variance))**4, weights=weights)
    
    return {
        'mean': weighted_mean,
        'variance': weighted_variance,
        'skewness': weighted_skew,
        'kurtosis': weighted_kurt
    }

# 가중치 설정 (최근 데이터에 더 높은 가중치)
weights = np.exp(np.linspace(-1, 0, len(damage_data)))
weights = weights / np.sum(weights)

# 가중 모멘트법 실행
weighted_moments = weighted_method_of_moments(damage_data, weights)
print("가중 모멘트:")
for key, value in weighted_moments.items():
    print(f"{key}: {value:.2f}")
```

### 2. 순서 통계량을 이용한 모멘트법

```python
def order_statistics_moments(data):
    """순서 통계량을 이용한 모멘트법"""
    
    # 데이터 정렬
    sorted_data = np.sort(data)
    n = len(sorted_data)
    
    # 순서 통계량 모멘트
    # 1차 모멘트 (중앙값)
    median = np.median(sorted_data)
    
    # 2차 모멘트 (사분위수 범위)
    q1 = np.percentile(sorted_data, 25)
    q3 = np.percentile(sorted_data, 75)
    iqr = q3 - q1
    
    # 3차 모멘트 (왜도)
    skewness = stats.skew(sorted_data)
    
    # 4차 모멘트 (첨도)
    kurtosis = stats.kurtosis(sorted_data)
    
    return {
        'median': median,
        'iqr': iqr,
        'skewness': skewness,
        'kurtosis': kurtosis
    }

# 순서 통계량 모멘트법 실행
order_moments = order_statistics_moments(damage_data)
print("순서 통계량 모멘트:")
for key, value in order_moments.items():
    print(f"{key}: {value:.2f}")
```

### 3. L-모멘트법

```python
def l_moments(data):
    """L-모멘트 계산"""
    
    # 데이터 정렬
    sorted_data = np.sort(data)
    n = len(sorted_data)
    
    # L-모멘트 계산
    # L1 (평균)
    l1 = np.mean(sorted_data)
    
    # L2 (첫 번째 L-모멘트)
    l2 = 0
    for i in range(n):
        l2 += (2*i - n + 1) * sorted_data[i]
    l2 = l2 / (n * (n - 1))
    
    # L3 (두 번째 L-모멘트)
    l3 = 0
    for i in range(n):
        l3 += (6*i**2 - 6*i*(n-1) + (n-1)*(n-2)) * sorted_data[i]
    l3 = l3 / (n * (n - 1) * (n - 2))
    
    # L4 (세 번째 L-모멘트)
    l4 = 0
    for i in range(n):
        l4 += (20*i**3 - 30*i**2*(n-1) + 12*i*(n-1)*(n-2) - (n-1)*(n-2)*(n-3)) * sorted_data[i]
    l4 = l4 / (n * (n - 1) * (n - 2) * (n - 3))
    
    return {
        'l1': l1,
        'l2': l2,
        'l3': l3,
        'l4': l4
    }

# L-모멘트법 실행
l_moments_result = l_moments(damage_data)
print("L-모멘트:")
for key, value in l_moments_result.items():
    print(f"{key}: {value:.2f}")
```

## 실무 적용 사례

### 사례 1: 자동차보험 손해액 분석

```python
def auto_insurance_damage_analysis():
    """자동차보험 손해액 분석"""
    
    # 실제 자동차보험 데이터 (예시)
    np.random.seed(42)
    n_samples = 2000
    
    # 혼합분포 데이터
    normal_damage = np.random.normal(2000, 500, 1200)
    severe_damage = np.random.gamma(2, 2000, 800)
    damage_data = np.concatenate([normal_damage, severe_damage])
    
    # 분포별 모멘트법 추정
    distributions = {
        '정규분포': method_of_moments_normal,
        '감마분포': method_of_moments_gamma,
        '지수분포': method_of_moments_exponential,
        '로그정규분포': method_of_moments_lognormal
    }
    
    results = {}
    
    for name, method in distributions.items():
        try:
            params = method(damage_data)
            results[name] = params
            print(f"{name}: {params}")
        except Exception as e:
            print(f"{name} 추정 실패: {e}")
    
    return results

# 자동차보험 손해액 분석 실행
damage_analysis = auto_insurance_damage_analysis()
```

### 사례 2: 보험료 산출 시스템

```python
def premium_calculation_with_moments(model, customer_data):
    """모멘트법을 통한 보험료 산출 시스템"""
    
    dist_name, params = model
    
    # 예측 손해액 분포
    if dist_name == '정규분포':
        predicted_damage = stats.norm.rvs(params[0], params[1], size=1000)
    elif dist_name == '감마분포':
        predicted_damage = stats.gamma.rvs(params[0], scale=params[1], size=1000)
    elif dist_name == '지수분포':
        predicted_damage = stats.expon.rvs(scale=params, size=1000)
    elif dist_name == '로그정규분포':
        predicted_damage = stats.lognorm.rvs(params[1], scale=np.exp(params[0]), size=1000)
    
    # 위험도 평가
    risk_percentile = np.percentile(predicted_damage, 95)
    expected_damage = np.mean(predicted_damage)
    
    # 보험료 계산
    base_premium = expected_damage * 0.1
    risk_loading = (risk_percentile - expected_damage) * 0.05
    total_premium = base_premium + risk_loading
    
    return {
        'expected_damage': expected_damage,
        'risk_percentile': risk_percentile,
        'base_premium': base_premium,
        'risk_loading': risk_loading,
        'total_premium': total_premium
    }

# 보험료 산출 시스템 실행
best_model = ('감마분포', damage_analysis['감마분포'])
customer_data = {'age': 30, 'driving_experience': 5}
premium_result = premium_calculation_with_moments(best_model, customer_data)
for key, value in premium_result.items():
    print(f"{key}: {value:.2f}")
```

## 모멘트법의 한계와 대안

### 1. 모멘트법의 한계

- **분포 가정**: 특정 분포 형태 가정 필요
- **모수 추정**: 제한된 모수로 복잡한 분포 모델링 어려움
- **이상치 민감성**: 극단적 값에 대한 과도한 영향

### 2. 대안 방법들

- **최대우도법**: 로그우도 함수 최대화
- **최소제곱법**: 분포 함수와 데이터 간의 차이 최소화
- **베이지안 방법**: 불확실성 정량화
- **비모수 방법**: 분포 가정 없이 데이터 분석

## 결론

모멘트법은 보험업계에서 분포 적합의 직관적이고 이해하기 쉬운 방법입니다. 특히 모수 추정의 단순성과 해석 가능성이 높아 보험 모델링에 직접적으로 활용할 수 있습니다.

다음 포스트에서는 적합도 검정을 활용한 분포 적합에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Distribution Fitting](https://real-statistics.com/distribution-fitting/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
