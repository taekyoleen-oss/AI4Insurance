---
title: "적합도 검정을 활용한 분포 적합과 보험 모델링"
date: "2025-02-13"
category: "model-fitting"
tags: ["적합도검정", "분포적합", "보험모델링"]
excerpt: "적합도 검정의 이론적 배경과 보험 모델링에서의 활용법을 살펴보고, 실무 적용 사례를 제공합니다."
---

적합도 검정(Goodness of Fit Test)은 분포 적합에서 가장 중요한 단계 중 하나입니다. 이번 포스트에서는 적합도 검정의 이론적 배경과 보험 모델링에서의 실무적 활용법을 자세히 살펴보겠습니다.

## 적합도 검정의 정의와 목적

적합도 검정은 주어진 데이터가 특정 확률분포를 따르는지 확인하는 통계적 방법입니다:

### 1. 적합도 검정의 목적

- **분포 확인**: 데이터가 특정 분포를 따르는지 검정
- **모델 선택**: 여러 분포 중 최적 분포 선택
- **모델 검증**: 적합된 모델의 유효성 검증
- **리스크 평가**: 모델의 신뢰성 평가

### 2. 주요 적합도 검정

- **Kolmogorov-Smirnov 검정**: 연속분포에 대한 적합도 검정
- **Anderson-Darling 검정**: 꼬리 부분에 민감한 적합도 검정
- **Chi-square 검정**: 이산분포에 대한 적합도 검정
- **Shapiro-Wilk 검정**: 정규분포에 대한 적합도 검정

## 보험업계에서의 적합도 검정 활용

### 1. 주요 활용 영역

- **손해액 분석**: 보험 손해액 분포의 적합도 검정
- **사고 빈도**: 사고 발생 빈도의 적합도 검정
- **생존시간**: 생명보험에서의 생존시간 적합도 검정
- **재해 분석**: 자연재해 손해액 분포 적합도 검정

### 2. 파이썬을 활용한 적합도 검정 구현

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats
from scipy.stats import norm, gamma, expon, weibull_min, lognorm
import warnings
warnings.filterwarnings('ignore')

# 보험 손해액 데이터 생성 (예시)
np.random.seed(42)
n_samples = 1000

# 정규분포에서 생성된 데이터
mu_true = 5000
sigma_true = 1000
damage_data = np.random.normal(mu_true, sigma_true, n_samples)

print("보험 손해액 데이터 기본 통계:")
print(f"평균: {np.mean(damage_data):.2f}")
print(f"표준편차: {np.std(damage_data):.2f}")
print(f"왜도: {stats.skew(damage_data):.2f}")
print(f"첨도: {stats.kurtosis(damage_data):.2f}")
```

### 3. Kolmogorov-Smirnov 검정

```python
def kolmogorov_smirnov_test(data, distribution='normal'):
    """Kolmogorov-Smirnov 검정"""
    
    if distribution == 'normal':
        # 정규분포 적합
        params = stats.norm.fit(data)
        dist = stats.norm
        dist_name = '정규분포'
        
    elif distribution == 'gamma':
        # 감마분포 적합
        params = stats.gamma.fit(data)
        dist = stats.gamma
        dist_name = '감마분포'
        
    elif distribution == 'exponential':
        # 지수분포 적합
        params = stats.expon.fit(data)
        dist = stats.expon
        dist_name = '지수분포'
        
    elif distribution == 'lognormal':
        # 로그정규분포 적합
        params = stats.lognorm.fit(data)
        dist = stats.lognorm
        dist_name = '로그정규분포'
    
    # KS 검정
    ks_stat, ks_pvalue = stats.kstest(data, lambda x: dist.cdf(x, *params))
    
    print(f"{dist_name} Kolmogorov-Smirnov 검정 결과:")
    print(f"  통계량: {ks_stat:.4f}")
    print(f"  p-value: {ks_pvalue:.4f}")
    
    if ks_pvalue > 0.05:
        print(f"  결론: {dist_name}을 따르지 않는다는 귀무가설을 기각할 수 없음 (p > 0.05)")
    else:
        print(f"  결론: {dist_name}을 따르지 않는다는 귀무가설을 기각 (p ≤ 0.05)")
    
    return ks_stat, ks_pvalue

# KS 검정 실행
distributions = ['normal', 'gamma', 'exponential', 'lognormal']
ks_results = {}

for dist in distributions:
    ks_stat, ks_pvalue = kolmogorov_smirnov_test(damage_data, dist)
    ks_results[dist] = (ks_stat, ks_pvalue)
```

### 4. Anderson-Darling 검정

```python
def anderson_darling_test(data, distribution='normal'):
    """Anderson-Darling 검정"""
    
    if distribution == 'normal':
        # 정규분포 적합
        params = stats.norm.fit(data)
        dist = stats.norm
        dist_name = '정규분포'
        
    elif distribution == 'gamma':
        # 감마분포 적합
        params = stats.gamma.fit(data)
        dist = stats.gamma
        dist_name = '감마분포'
        
    elif distribution == 'exponential':
        # 지수분포 적합
        params = stats.expon.fit(data)
        dist = stats.expon
        dist_name = '지수분포'
        
    elif distribution == 'lognormal':
        # 로그정규분포 적합
        params = stats.lognorm.fit(data)
        dist = stats.lognorm
        dist_name = '로그정규분포'
    
    # AD 검정
    ad_stat, ad_critical, ad_significance = stats.anderson(data, dist.name)
    
    print(f"{dist_name} Anderson-Darling 검정 결과:")
    print(f"  통계량: {ad_stat:.4f}")
    print(f"  임계값: {ad_critical}")
    print(f"  유의수준: {ad_significance}")
    
    # 임계값과 비교
    if ad_stat < ad_critical[2]:  # 5% 유의수준
        print(f"  결론: {dist_name}을 따르지 않는다는 귀무가설을 기각할 수 없음")
    else:
        print(f"  결론: {dist_name}을 따르지 않는다는 귀무가설을 기각")
    
    return ad_stat, ad_critical, ad_significance

# AD 검정 실행
ad_results = {}

for dist in distributions:
    ad_stat, ad_critical, ad_significance = anderson_darling_test(damage_data, dist)
    ad_results[dist] = (ad_stat, ad_critical, ad_significance)
```

### 5. Chi-square 검정

```python
def chi_square_test(data, distribution='normal', bins=20):
    """Chi-square 검정"""
    
    if distribution == 'normal':
        # 정규분포 적합
        params = stats.norm.fit(data)
        dist = stats.norm
        dist_name = '정규분포'
        
    elif distribution == 'gamma':
        # 감마분포 적합
        params = stats.gamma.fit(data)
        dist = stats.gamma
        dist_name = '감마분포'
        
    elif distribution == 'exponential':
        # 지수분포 적합
        params = stats.expon.fit(data)
        dist = stats.expon
        dist_name = '지수분포'
        
    elif distribution == 'lognormal':
        # 로그정규분포 적합
        params = stats.lognorm.fit(data)
        dist = stats.lognorm
        dist_name = '로그정규분포'
    
    # 히스토그램 생성
    observed, bins = np.histogram(data, bins=bins)
    
    # 기댓값 계산
    bin_centers = (bins[:-1] + bins[1:]) / 2
    bin_widths = bins[1:] - bins[:-1]
    expected = dist.pdf(bin_centers, *params) * len(data) * bin_widths
    
    # Chi-square 검정
    chi2_stat, chi2_pvalue = stats.chisquare(observed, expected)
    
    print(f"{dist_name} Chi-square 검정 결과:")
    print(f"  통계량: {chi2_stat:.4f}")
    print(f"  p-value: {chi2_pvalue:.4f}")
    
    if chi2_pvalue > 0.05:
        print(f"  결론: {dist_name}을 따르지 않는다는 귀무가설을 기각할 수 없음 (p > 0.05)")
    else:
        print(f"  결론: {dist_name}을 따르지 않는다는 귀무가설을 기각 (p ≤ 0.05)")
    
    return chi2_stat, chi2_pvalue

# Chi-square 검정 실행
chi2_results = {}

for dist in distributions:
    chi2_stat, chi2_pvalue = chi_square_test(damage_data, dist)
    chi2_results[dist] = (chi2_stat, chi2_pvalue)
```

## 엑셀을 활용한 적합도 검정

### 1. 기본 설정

```excel
A1: 손해액
B1: 순위
C1: 누적확률
D1: 이론적누적확률
E1: 차이

A2: =RAND()*5000+1000
B2: =RANK(A2,$A$2:$A$1001)
C2: =B2/1000
D2: =NORM.DIST(A2,AVERAGE(A2:A1001),STDEV(A2:A1001),TRUE)
E2: =ABS(C2-D2)
```

### 2. Kolmogorov-Smirnov 검정

```excel
# KS 통계량 계산
A5: KS 통계량
B5: =MAX(E2:E1001)

# 임계값 (5% 유의수준)
A6: 임계값
B6: =1.36/SQRT(1000)

# 검정 결과
A7: 검정결과
B7: =IF(B5>B6,"기각","수용")
```

### 3. Chi-square 검정

```excel
# 히스토그램 구간 설정
A10: 구간
B10: 관측빈도
C10: 기댓값
D10: Chi-square

A11: 0-1000
B11: =COUNTIF(A2:A1001,"<=1000")
C11: =NORM.DIST(1000,AVERAGE(A2:A1001),STDEV(A2:A1001),TRUE)*1000
D11: =(B11-C11)^2/C11

A12: 1000-2000
B12: =COUNTIFS(A2:A1001,">1000",A2:A1001,"<=2000")
C12: =(NORM.DIST(2000,AVERAGE(A2:A1001),STDEV(A2:A1001),TRUE)-NORM.DIST(1000,AVERAGE(A2:A1001),STDEV(A2:A1001),TRUE))*1000
D12: =(B12-C12)^2/C12
```

## 고급 분석 기법

### 1. 다중 적합도 검정

```python
def multiple_goodness_of_fit_tests(data, distributions):
    """다중 적합도 검정"""
    
    results = {}
    
    for dist_name in distributions:
        # 분포 적합
        if dist_name == 'normal':
            params = stats.norm.fit(data)
            dist = stats.norm
        elif dist_name == 'gamma':
            params = stats.gamma.fit(data)
            dist = stats.gamma
        elif dist_name == 'exponential':
            params = stats.expon.fit(data)
            dist = stats.expon
        elif dist_name == 'lognormal':
            params = stats.lognorm.fit(data)
            dist = stats.lognorm
        
        # KS 검정
        ks_stat, ks_pvalue = stats.kstest(data, lambda x: dist.cdf(x, *params))
        
        # AD 검정
        ad_stat, ad_critical, ad_significance = stats.anderson(data, dist.name)
        
        # Chi-square 검정
        observed, bins = np.histogram(data, bins=20)
        bin_centers = (bins[:-1] + bins[1:]) / 2
        bin_widths = bins[1:] - bins[:-1]
        expected = dist.pdf(bin_centers, *params) * len(data) * bin_widths
        chi2_stat, chi2_pvalue = stats.chisquare(observed, expected)
        
        results[dist_name] = {
            'ks_stat': ks_stat,
            'ks_pvalue': ks_pvalue,
            'ad_stat': ad_stat,
            'chi2_stat': chi2_stat,
            'chi2_pvalue': chi2_pvalue
        }
    
    return results

# 다중 적합도 검정 실행
multiple_results = multiple_goodness_of_fit_tests(damage_data, distributions)
```

### 2. 적합도 검정 시각화

```python
def visualize_goodness_of_fit(data, distribution='normal'):
    """적합도 검정 시각화"""
    
    # 분포 적합
    if distribution == 'normal':
        params = stats.norm.fit(data)
        dist = stats.norm
        dist_name = '정규분포'
    elif distribution == 'gamma':
        params = stats.gamma.fit(data)
        dist = stats.gamma
        dist_name = '감마분포'
    elif distribution == 'exponential':
        params = stats.expon.fit(data)
        dist = stats.expon
        dist_name = '지수분포'
    elif distribution == 'lognormal':
        params = stats.lognorm.fit(data)
        dist = stats.lognorm
        dist_name = '로그정규분포'
    
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
    
    # 히스토그램과 이론적 분포
    ax1.hist(data, bins=50, alpha=0.7, density=True, color='skyblue', label='데이터')
    x = np.linspace(data.min(), data.max(), 100)
    ax1.plot(x, dist.pdf(x, *params), 'r-', linewidth=2, label=f'{dist_name} 적합')
    ax1.set_title(f'{dist_name} 적합도')
    ax1.set_xlabel('손해액')
    ax1.set_ylabel('밀도')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # Q-Q 플롯
    stats.probplot(data, dist=dist, sparams=params, plot=ax2)
    ax2.set_title(f'{dist_name} Q-Q 플롯')
    ax2.grid(True, alpha=0.3)
    
    # 누적분포함수
    sorted_data = np.sort(data)
    y = np.arange(1, len(sorted_data) + 1) / len(sorted_data)
    ax3.plot(sorted_data, y, 'b-', linewidth=2, label='경험적 CDF')
    ax3.plot(x, dist.cdf(x, *params), 'r-', linewidth=2, label=f'{dist_name} CDF')
    ax3.set_title(f'{dist_name} 누적분포함수')
    ax3.set_xlabel('손해액')
    ax3.set_ylabel('누적확률')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 잔차 플롯
    residuals = y - dist.cdf(sorted_data, *params)
    ax4.scatter(sorted_data, residuals, alpha=0.6)
    ax4.axhline(y=0, color='r', linestyle='--')
    ax4.set_title(f'{dist_name} 잔차 플롯')
    ax4.set_xlabel('손해액')
    ax4.set_ylabel('잔차')
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# 적합도 검정 시각화 실행
visualize_goodness_of_fit(damage_data, 'normal')
```

## 실무 적용 사례

### 사례 1: 자동차보험 손해액 적합도 검정

```python
def auto_insurance_damage_goodness_of_fit():
    """자동차보험 손해액 적합도 검정"""
    
    # 실제 자동차보험 데이터 (예시)
    np.random.seed(42)
    n_samples = 2000
    
    # 혼합분포 데이터
    normal_damage = np.random.normal(2000, 500, 1200)
    severe_damage = np.random.gamma(2, 2000, 800)
    damage_data = np.concatenate([normal_damage, severe_damage])
    
    # 분포별 적합도 검정
    distributions = ['normal', 'gamma', 'exponential', 'lognormal']
    results = {}
    
    for dist in distributions:
        # 분포 적합
        if dist == 'normal':
            params = stats.norm.fit(damage_data)
            dist_obj = stats.norm
        elif dist == 'gamma':
            params = stats.gamma.fit(damage_data)
            dist_obj = stats.gamma
        elif dist == 'exponential':
            params = stats.expon.fit(damage_data)
            dist_obj = stats.expon
        elif dist == 'lognormal':
            params = stats.lognorm.fit(damage_data)
            dist_obj = stats.lognorm
        
        # KS 검정
        ks_stat, ks_pvalue = stats.kstest(damage_data, lambda x: dist_obj.cdf(x, *params))
        
        # AD 검정
        ad_stat, ad_critical, ad_significance = stats.anderson(damage_data, dist_obj.name)
        
        # Chi-square 검정
        observed, bins = np.histogram(damage_data, bins=20)
        bin_centers = (bins[:-1] + bins[1:]) / 2
        bin_widths = bins[1:] - bins[:-1]
        expected = dist_obj.pdf(bin_centers, *params) * len(damage_data) * bin_widths
        chi2_stat, chi2_pvalue = stats.chisquare(observed, expected)
        
        results[dist] = {
            'ks_pvalue': ks_pvalue,
            'ad_stat': ad_stat,
            'chi2_pvalue': chi2_pvalue
        }
    
    # 최적 분포 선택
    best_dist = max(results.items(), key=lambda x: x[1]['ks_pvalue'])
    print(f"최적 분포: {best_dist[0]} (KS p-value: {best_dist[1]['ks_pvalue']:.4f})")
    
    return best_dist

# 자동차보험 손해액 적합도 검정 실행
best_dist = auto_insurance_damage_goodness_of_fit()
```

### 사례 2: 보험료 산출 시스템

```python
def premium_calculation_with_goodness_of_fit(model, customer_data):
    """적합도 검정을 통한 보험료 산출 시스템"""
    
    dist_name, results = model
    
    # 분포 적합
    if dist_name == 'normal':
        params = stats.norm.fit(customer_data['damage_amount'])
        dist = stats.norm
    elif dist_name == 'gamma':
        params = stats.gamma.fit(customer_data['damage_amount'])
        dist = stats.gamma
    elif dist_name == 'exponential':
        params = stats.expon.fit(customer_data['damage_amount'])
        dist = stats.expon
    elif dist_name == 'lognormal':
        params = stats.lognorm.fit(customer_data['damage_amount'])
        dist = stats.lognorm
    
    # 예측 손해액 분포
    predicted_damage = dist.rvs(*params, size=1000)
    
    # 위험도 평가
    risk_percentile = np.percentile(predicted_damage, 95)
    expected_damage = np.mean(predicted_damage)
    
    # 보험료 계산
    base_premium = expected_damage * 0.1
    risk_loading = (risk_percentile - expected_damage) * 0.05
    total_premium = base_premium + risk_loading
    
    return {
        'expected_damage': expected_damage,
        'risk_percentile': risk_percentile,
        'base_premium': base_premium,
        'risk_loading': risk_loading,
        'total_premium': total_premium
    }

# 보험료 산출 시스템 실행
customer_data = {'damage_amount': damage_data}
premium_result = premium_calculation_with_goodness_of_fit(best_dist, customer_data)
for key, value in premium_result.items():
    print(f"{key}: {value:.2f}")
```

## 적합도 검정의 한계와 대안

### 1. 적합도 검정의 한계

- **분포 가정**: 특정 분포 형태 가정 필요
- **모수 추정**: 제한된 모수로 복잡한 분포 모델링 어려움
- **이상치 민감성**: 극단적 값에 대한 과도한 영향

### 2. 대안 방법들

- **비모수 방법**: 분포 가정 없이 데이터 분석
- **머신러닝**: 랜덤포레스트, 신경망
- **베이지안 방법**: 불확실성 정량화
- **앙상블**: 여러 분포의 조합

## 결론

적합도 검정은 보험업계에서 분포 적합의 핵심 기법입니다. 특히 모델의 유효성 검증과 신뢰성 평가에 직접적으로 활용할 수 있습니다.

다음 포스트에서는 분포 적합의 실무 적용 사례에 대해 살펴보겠습니다.

## 참고자료

- [Real Statistics - Distribution Fitting](https://real-statistics.com/distribution-fitting/)
- Klugman, S. A., Panjer, H. H., & Willmot, G. E. (2012). Loss Models: From Data to Decisions
- Kaas, R., Goovaerts, M., Dhaene, J., & Denuit, M. (2008). Modern Actuarial Risk Theory
